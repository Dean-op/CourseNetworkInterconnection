# 1 Vlan Trunk

## 1.1 概念

### VLAN

VLAN（Virtual Local Area Network，虚拟局域网）==是一种将网络中的设备逻辑上分组的技术，尽管这些设备可能物理上位于不同的局域网中。==VLAN允许在同一物理网络基础设施上创建多个逻辑隔离的网络，使得不同的VLAN内的设备可以像在不同的局域网中一样通信，而无需物理分离。 

VLAN的主要特点：

1. ==**逻辑隔离**：每个VLAN是一个独立的广播域，不同VLAN之间的设备无法直接通信，除非通过三层设备（如路由器或三层交换机）。==
2. **灵活性和可扩展性**：VLAN可以跨越多台交换机，并且通过配置，网络管理员可以灵活地分配不同设备到不同的VLAN，而不受物理位置的限制。
3. **增强安全性**：通过将敏感设备分配到特定的VLAN，可以减少广播风暴的范围并隔离流量，提升网络安全性。

### TRUNK（中继）

==TRUNK是一种用于在交换机之间传输多个VLAN流量的链路。====它**允许不同的VLAN数据通过同一物理链路，保持每个VLAN的独立性**。==TRUNK链路上的流量使用**IEEE 802.1Q**封装协议，在每个以太帧中插入一个VLAN标记（Tag）以区分不同的VLAN。

TRUNK的主要特点：

1. ==**多VLAN数据传输**：TRUNK端口用于在多个交换机之间传输多个VLAN的流量，保持各VLAN的逻辑隔离。==
2. **802.1Q封装协议**：该协议在以太网帧中插入4字节的VLAN Tag字段，用于标识VLAN ID，这样交换机能够识别来自不同VLAN的帧。
3. **适用于跨交换机的VLAN扩展**：通过TRUNK连接不同交换机，可以实现VLAN在整个网络中的扩展。例如，VLAN 10在多个交换机上都可以存在，通过TRUNK端口在交换机之间转发VLAN 10的流量。

VLAN与TRUNK的关系：

- **VLAN**将网络中的设备分隔成不同的广播域，允许不同的部门或用户组逻辑隔离。
- **TRUNK**则用于在交换机之间传输这些VLAN的数据，确保每个VLAN的数据在多个交换机间传递时保持隔离。

## ==1.2 常用命令==

- 创建vlan

  ```c
  Switch#vlan database   //进入vlan数据库
  Switch(vlan)#vlan 2	//创建vlan2
  Switch(vlan)#vlan 3	//创建vlan3
  
  或进入全局配置模式直接创建vlan
  Switch(config)#vlan 4
  ```

  

- 将接口划分到指定vlan

  ```c
  Switch(config)#interface f0/2	//进入0模块2网口
  Switch(config-if)#switchport access vlan 2	//将0模块2网口加入vlan2
  
  将接口批量加入vlan
  Switch(config)#interface range f0/3-10	//进入3~10接口
  Switch(config-if)#switchport access vlan 2	//将3~10接口加入vlan2
  ```

  

- 切换接口模式

  ```c
  Switch(config)#interface f0/24  //进入接口
  Switch(config-if)#switchport  mode  trunk	//将0模块24网口模式切换为trunk
  ```

  







# 2 默认路由和静态路由

### 2.1 默认路由（Default Route）

==**默认路由**是一条特殊的路由，它用来处理发送到路由器但没有明确匹配路由表中任何目的地址的流量。==默认路由通常用于将未知目的地的流量发送到一个指定的网关。默认路由的网络地址是 `0.0.0.0/0`，也就是匹配所有地址。

**默认路由的用途**：

1. **出口路由**：默认路由经常用在小型或边缘网络，配置为通向ISP的出口路由，所有非本地网络的流量都会通过默认路由发送到ISP。
2. **节省路由表空间**：通过配置一条默认路由，网络管理员可以减少手动配置每个外部网络的具体路由，简化配置工作。
  

==**默认路由的配置方法：**==

假设我们有一个下一跳为 `192.168.1.1` 的路由器，默认路由的配置如下：

```c
Router(config)#ip route 0.0.0.0 0.0.0.0 192.168.1.1
```

- `0.0.0.0 0.0.0.0` 是默认路由的标志，匹配所有目标IP。
- `192.168.1.1` 是下一跳地址，所有未知目的地的流量都会发送到这个地址。

---

### 2.2 静态路由（Static Route）

==**静态路由**是网络管理员手动配置的特定路由，它将数据流量从一个网络转发到特定的目的地。==静态路由需要指定目标网络、子网掩码和下一跳地址或出接口。

**静态路由的特点**：

1. **手动配置**：与动态路由协议（如RIP、OSPF、BGP）不同，静态路由必须由管理员手动添加、修改和删除。
2. **无开销**：静态路由不会产生协议开销，因此在小型、固定拓扑的网络中非常高效。
3. **灵活控制**：网络管理员可以通过静态路由精确控制流量的路径，但在拓扑变化时需要手动调整。

==**静态路由的配置方法**：==

==假设有一条到 `192.168.2.0/24` 网络的静态路由，下一跳为 `192.168.1.2`，配置如下：==

```c
Router(config)#ip route 192.168.2.0 255.255.255.0 192.168.1.2
```

- `192.168.2.0` 是目标网络的地址。

- `255.255.255.0` 是子网掩码。

- `192.168.1.2` 是通向目标网络的下一跳地址。

  

**静态路由的另一种配置方式**（出接口方式）：

如果下一跳直接连接，可以指定出接口而不是下一跳IP地址。例如，配置到 `192.168.2.0` 的静态路由通过接口 `FastEthernet0/1`：

```c
Router(config)#ip route 192.168.2.0 255.255.255.0 FastEthernet0/1
```

---

### 2.3 默认路由与静态路由的区别：
1. **匹配方式**：静态路由是针对特定目标网络的，而默认路由适用于所有没有明确路由的流量。
2. **使用场景**：
   - 静态路由用于有明确网络拓扑和需要精确流量控制的情况。
   - 默认路由通常用于处理所有外部网络流量或小型网络的出口路由。
3. **管理负担**：静态路由需要人工维护，拓扑变化时要手动更新；默认路由较简单，通常配置一次即可应对大多数流量。

---

**==配置示例总结：==**

- 默认路由：`ip route 0.0.0.0 0.0.0.0 [next-hop]`
- 静态路由：`ip route [destination-network] [subnet-mask] [next-hop]`



# 3 RIP协议

### 3.1 RIP协议介绍

RIP（Routing Information Protocol）==是一个基于距离矢量的动态路由协议==，最早开发于20世纪80年代，用于小型网络。它通过周期性地与邻居路由器交换路由表来更新路由信息，进而实现动态路由的维护。==RIP的工作原理是通过**跳数**（Hop Count）来选择最佳路由路径，跳数即为数据包从源路由器到目标路由器之间经过的路由器数量。==

**RIP的主要特点：**

1. **距离矢量协议**：==RIP根据到达目标网络的跳数选择路径，跳数越少，路径越优。最大跳数为15，超过15跳的路由会被视为不可达。==
2. **定时更新**：==RIP默认每隔30秒向邻居路由器广播自己的路由表。==
3. **路由老化机制**：如果路由器在180秒内没有收到某条路由的更新，将认为该路由不可达并将其从路由表中删除。
4. **最大跳数限制**：RIP的最大跳数为15跳，超过此限制的网络将被视为不可达，这限制了RIP的适用范围，适合小型网络。

**RIP的版本：**

1. **RIPv1**：使用广播方式发送更新，不支持子网掩码，因此不支持VLSM（可变长子网掩码）和CIDR（无类别域间路由）。
2. **RIPv2**：通过多播地址 `224.0.0.9` 发送更新，支持VLSM和CIDR，能够更有效地处理现代网络。

---

### 3.2 RIP协议的配置方法

2. ==启用RIP协议==

```c
Router(config)#router rip
```

- **`router rip`**：进入RIP的配置模式，启用RIP协议。

3. ==指定RIP版本==

```c
Router(config-router)#version 2
```

- **`version 2`**：指定使用RIP版本2（RIPv2），它支持VLSM和CIDR。

4. ==配置网络==

```c
Router(config-router)#network 192.168.1.0
Router(config-router)#network 10.0.0.0
```

- ==**`network`**：该命令用于告诉RIP哪个网络要被通告，以及在哪些接口上发送RIP更新。==
- ==例如，**`network 192.168.1.0`** 表示路由器将通告192.168.1.0/24网络，并向连接这个网络的接口发送RIP更新。==

5. 配置RIP定时器（可选）

```c
Router(config-router)#timers basic 30 180 180 240
```

- **`timers basic`**：此命令配置RIP的更新间隔（30秒）、失效时间（180秒）、保持时间（180秒）和刷新时间（240秒）。可以根据网络需求进行优化配置。

7. 保存配置

```c
Router#write memory
```

- **`write memory`**：保存路由器配置，以确保路由器重启后配置仍然生效。

---

### 3.3 配置示例

假设我们有两个网络，`192.168.1.0/24` 和 `10.0.0.0/8`，我们在路由器上配置RIP并通告这两个网络。

```c
Router>enable
Router#configure terminal
Router(config)#router rip
Router(config-router)#version 2
Router(config-router)#network 192.168.1.0
Router(config-router)#network 10.0.0.0
Router(config-router)#end
Router#write memory
```

- **`router rip`**：启用RIP协议。
- **`version 2`**：指定使用RIPv2版本。
- **`network`**：将 `192.168.1.0/24` 和 `10.0.0.0/8` 网络加入到RIP的路由通告中。
- **`write memory`**：保存配置。

---

### 3.4 RIP协议的优缺点

优点：

- **简单易用**：配置简单，适合小型网络。
- **自动路由更新**：RIP可以动态学习和更新路由表，无需手动配置每条路由。

缺点：

- **跳数限制**：最大跳数为15，限制了RIP在大规模网络中的应用。
- **收敛速度慢**：RIP的更新间隔较长，收敛速度慢，可能会导致网络中断时延迟更新。
- **不适合复杂网络**：RIP不支持大规模和复杂网络，现代网络中大多使用更高级的路由协议如OSPF或EIGRP。

RIP协议通常在小型或简单网络中使用，大型网络则倾向于使用OSPF或BGP等更先进的动态路由协议。



# 4 OSPF协议

### 4.1 OSPF协议介绍

OSPF（Open Shortest Path First）==是一种基于链路状态的动态路由协议==，广泛应用于大型和复杂的IP网络中。它是由IETF（互联网工程任务组）开发并标准化的，属于内部网关协议（IGP）的一种。OSPF在许多企业和服务提供商网络中使用，因为它具备高效性和灵活性。

**OSPF的主要特点：**

1. ==**链路状态协议**：OSPF通过交换链路状态信息（LSA）来构建和维护路由表，每个路由器都可以独立计算到达每个网络的最佳路径。==
2. ==**区域划分**：OSPF可以将网络划分为多个区域，**区域0为骨干区域，其他区域通过骨干区域互联**。==这种设计可以提高路由的可扩展性和管理效率。
3. **快速收敛**：当网络拓扑发生变化时，OSPF能够快速收敛，更新路由信息，提高网络的稳定性。
4. **支持VLSM和CIDR**：OSPF支持可变长度子网掩码（VLSM）和无类别域间路由（CIDR），能够更有效地利用IP地址。
5. **多播更新**：OSPF使用多播地址（224.0.0.5和224.0.0.6）来发送更新信息，提高网络带宽的利用率。

==**OSPF的工作原理：**==

1. **邻居发现**：路由器通过发送Hello报文发现邻居路由器，建立邻接关系。
2. **LSA交换**：邻居路由器之间交换链路状态信息，路由器根据这些信息构建链路状态数据库（LSDB）。
3. **最短路径计算**：每个路由器使用Dijkstra算法计算到达每个目的地的最短路径，并更新路由表。
4. **周期性更新**：OSPF路由器定期发送LSA以维持网络状态的最新，确保路由信息的准确性。

---

### ==4.2 OSPF的配置方法==

在思科（Cisco）路由器上，配置OSPF的步骤如下：

**1. 启用OSPF协议**

```c
Router(config)#router ospf 1
```

- **`router ospf 1`**：启用OSPF协议，其中1是OSPF进程号。多个OSPF进程可以在同一路由器上运行，进程号是其唯一标识。

**2. 配置OSPF网络**

```c
Router(config-router)#network 192.168.1.0 0.0.0.255 area 0
Router(config-router)#network 192.168.2.0 0.0.0.255 area 1
```

- **`network`**：用于将指定的网络添加到OSPF进程中，并将其划分到特定区域。
  - `192.168.1.0 0.0.0.255 area 0`：将 `192.168.1.0/24` 网络添加到OSPF进程，并将其分配到区域0（骨干区域）。
  - `192.168.2.0 0.0.0.255 area 1`：将 `192.168.2.0/24` 网络添加到OSPF进程，并将其分配到区域1

---

### 4.3 配置示例

假设我们有两个网络，`192.168.1.0/24` 和 `192.168.2.0/24`，我们在路由器上配置OSPF并通告这两个网络。

```c
1. Router#ip routing
   // 启用路由功能，确保路由器可以进行IP路由。

2. Router(config)#router ospf 100
   // 启用OSPF协议，100是进程号，多个OSPF进程可以在同一路由器上运行。

3. Router(config-router)#network 192.168.1.0 0.0.0.255 area 1
   // 将192.168.1.0/24网络添加到OSPF进程中，并指定其属于区域1。反掩码（wildcard mask）0.0.0.255表示匹配192.168.1.0到192.168.1.255的所有地址。

4. Router(config-router)#network 192.168.2.0 0.0.0.255 area 0
   // 将192.168.2.0/24网络添加到OSPF进程中，并指定其属于区域0（骨干区域）。反掩码0.0.0.255同样表示匹配192.168.2.0到192.168.2.255的所有地址。

5. Router(config-router)#end
   // 退出OSPF配置模式，返回到特权模式。

6. Router#sh ip ro
   // 显示当前路由器的IP路由表，以检查OSPF学习到的路由。

7. Router#wr
   // 保存当前的配置，以确保在路由器重启后配置仍然生效。

```

### 4.4 OSPF协议的优缺点

优点：

- **快速收敛**：OSPF能快速响应网络拓扑的变化，适应性强。
- **支持大规模网络**：能够有效支持大型企业和服务提供商网络。
- **支持VLSM和CIDR**：更灵活的IP地址管理和分配。

缺点：

- **配置复杂性**：相较于RIP，OSPF的配置和管理更为复杂。
- **资源消耗**：OSPF在内存和CPU资源的消耗上相对较高，尤其是在大型网络中。

OSPF是现代网络设计中最常用的动态路由协议之一，适用于需要高效和灵活路由管理的环境。

![image-20241016082147790](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241016082147790.png)

# 5 单臂路由

### 5.1前缀概念

**默认网关**，就像是一个城市的大门，==是连接本地网络和外部网络的桥梁==。当你的电脑想要访问互联网上的其他设备（比如访问一个网站）时，如果目标设备不在你的本地网络中，你的电脑就会通过默认网关来转发这个请求。作用：

- **路由决策:** 当你的电脑需要向一个不在本地网络中的设备发送数据包时，它会查看自己的路由表。如果路由表中没有找到一条直接到达目标网络的路由，那么它就会将数据包发送给默认网关。

- **数据转发:** 默认网关（通常是一个路由器）会接收到这个数据包，然后根据它的路由表，决定将数据包转发到哪个网络。

- **连接不同网络:** 通过这种方式，默认网关连接了你的本地网络和外部网络，使得你的电脑可以访问互联网上的各种资源。

  

**单臂路由**，也称为“路由器上的棍子”，==是一种在路由器的一个物理接口上配置多个逻辑子接口，实现多个VLAN之间互联互通的技术。==简单来说，就是通过在路由器上创建一个虚拟的“手臂”，让多个VLAN“抓住”这个“手臂”，从而实现相互通信。

### 5.2 单臂路由的工作原理

1. ==**物理接口与逻辑子接口:**==

   - ==路由器上有一个物理接口连接到交换机。==
   - ==在这个物理接口上，配置多个逻辑子接口，每个逻辑子接口对应一个VLAN。==
   - ==路由器会对数据包进行封装和解封装，在不同的VLAN之间进行转发。==

2. ==**VLAN间的通信:**==

   - ==当一个VLAN中的主机需要向另一个VLAN中的主机发送数据时：==

     - ==数据包首先被封装上源VLAN的标签。==

     - ==路由器收到数据包后，根据VLAN标签，将数据包剥离原来的标签，并封装上目的VLAN的标签。==

     - ==然后，路由器将数据包转发到对应的逻辑子接口，最终到达目的主机。==

       

单臂路由的优点

- **节省接口资源:** 相比于为每个VLAN配置一个物理接口，单臂路由可以大大节省路由器的接口资源。
- **简化配置:** 配置相对简单，只需要在路由器上配置子接口和VLAN即可。
- **灵活扩展:** 可以根据需要增加或减少VLAN，方便网络的扩展。

### ==5.3单臂路由的配置方法==

单臂路由（One-Armed Routing）的配置方法允许通过单个物理接口处理多个 VLAN 的流量。下面是配置单臂路由的步骤和示例。

1. **创建 VLAN 分配接口至VLAN：**
  
   ```c
   Switch(config)# vlan 10
   Switch(config-vlan)# exit
   Switch(config)# vlan 20
   Switch(config-vlan)# exit
   Switch(config)# interface f0/1
   Switch(config-if)# switchport access vlan 10  // 将 f0/1 接口加入 VLAN 10
   Switch(config-if)# exit
   
   Switch(config)# interface f0/2
   Switch(config-if)# switchport access vlan 20  // 将 f0/2 接口加入 VLAN 20
   Switch(config-if)# exit
   ```
   
   
   
3. **配置 Trunk 接口**：
  
   - 配置一个 Trunk 接口，以便通过它传递多个 VLAN 的流量。
   
   ```c
   Switch(config)# interface f0/3
   Switch(config-if)# switchport mode trunk  // 将 f0/3 设置为 Trunk 模式
   Switch(config-if)# exit
   ```
   
6. ==**配置路由器的子接口**：==
  
   - 在路由器上创建子接口，使用 802.1Q 封装并为每个子接口配置 IP 地址。
   
   ```c
   Router(config)# interface f0/0
   Router(config-if)# no shutdown  // 启用接口
   
   Router(config)# interface f0/0.1
   Router(config-subif)# encapsulation dot1Q 10  // 封装 VLAN 10
   Router(config-subif)# ip address 192.168.1.254 255.255.255.0  // IP 地址
   Router(config-subif)# exit
   
   Router(config)# interface f0/0.2
   Router(config-subif)# encapsulation dot1Q 20  // 封装 VLAN 20
   Router(config-subif)# ip address 192.168.2.254 255.255.255.0  // IP 地址
   Router(config-subif)# exit
   ```
   
   `encapsulation dot1Q 10` 的意思是将该子接口（如 f0/0.1）配置为使用 802.1Q VLAN 封装协议，并指定该子接口将处理 VLAN 10 的流量。具体解释如下：
   
   1. **802.1Q 封装**：
      - ==802.1Q 是一种 VLAN 标记协议，用于在以太网帧中插入 VLAN 标签。这个标签包含了 VLAN 的信息，使得交换机和路由器能够识别数据包属于哪个 VLAN。==
   
   2. **VLAN 10**：
      - ==`10` 表示此子接口将处理属于 VLAN 10 的流量。==当 VLAN 10 中的设备发送数据包时，802.1Q 封装会在数据包中添加 VLAN 标签，以指示其 VLAN 所属。
   
   `encapsulation dot1Q 10` 配置使得路由器能够识别并处理 VLAN 10 的流量，同时支持通过该接口的多 VLAN 传输，实现 VLAN 间的路由功能。

![image-20241009171627342](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241009171627342.png)

















# 6 多端口路由器互联Vlan

### 6.1 解决的问题

- **VLAN 隔离**：
  - 各个 VLAN 内的设备能够互相通信，而 VLAN 之间的设备则需要通过路由器进行访问，保证了网络的隔离性。

- ==**跨 VLAN 路由**：==
  - ==配置的路由器能够提供不同 VLAN 之间的路由功能，使得不同 VLAN 内的设备能够进行数据交换。==

### ==6.2 路由器互联Vlan配置方法==

1. **交换机配置**：
   - **创建 VLAN**：
     - 在交换机上创建三个 VLAN（2、3、4），为不同的网络段做好划分。
   - **配置接入端口**：
     - 将接口 f0/1 到 f0/3 设置为接入模式，并加入 VLAN 2。
     - 将接口 f0/4 到 f0/6 设置为接入模式，并加入 VLAN 3。
     - 将接口 f0/7 到 f0/9 设置为接入模式，并加入 VLAN 4。
2. **路由器配置**：
   - **配置接口 IP 地址**：
     - 在路由器的 g0/0、g0/1 和 g0/2 接口上分别配置 IP 地址，作为 VLAN 2、3 和 4 的默认网关。
   - **启用接口**：
     - 确保所有配置的接口都处于启用状态。
   - **查看路由表**：
     - 使用 `show ip route` 命令确认路由表正确配置。

![image-20241016085902507](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241016085902507.png)

```c
Switch>en
Switch#vl da               // 进入VLAN数据库模式
Switch(vlan)#vl 2          // 创建VLAN 2
Switch(vlan)#vl 3          // 创建VLAN 3
Switch(vlan)#vl 4          // 创建VLAN 4
Switch(vlan)#exit
Switch#conf t              // 进入全局配置模式
Switch(config)#in ra f0/1-3 // 进入接口范围 f0/1 到 f0/3
Switch(config-if-range)#sw mo ac  // 将接口设置为接入模式
Switch(config-if-range)#sw ac vl 2  // 将接口加入VLAN 2
Switch(config-if-range)#exit
Switch(config)#in ra f0/4-6 // 进入接口范围 f0/4 到 f0/6
Switch(config-if-range)#sw mo ac  // 将接口设置为接入模式
Switch(config-if-range)#sw ac vl 3  // 将接口加入VLAN 3
Switch(config-if-range)#exit
Switch(config)#in ra f0/7-9 // 进入接口范围 f0/7 到 f0/9
Switch(config-if-range)#sw mo ac  // 将接口设置为接入模式
Switch(config-if-range)#sw ac vl 4  // 将接口加入VLAN 4
Switch(config-if-range)#end
Switch#sh vl               // 查看VLAN配置信息

Router>en
Router#conf t              // 进入全局配置模式
Router(config)#in g0/0     // 进入接口 g0/0
Router(config-if)#ip ad 192.168.1.254 255.255.255.0 // 配置IP地址
Router(config-if)#no sh    // 启用该接口
Router(config-if)#exit
Router(config)#in g0/1     // 进入接口 g0/1
Router(config-if)#ip ad 192.168.2.254 255.255.255.0 // 配置IP地址
Router(config-if)#no sh    // 启用该接口
Router(config-if)#exit
Router(config)#in g0/2     // 进入接口 g0/2
Router(config-if)#ip ad 192.168.3.254 255.255.255.0 // 配置IP地址
Router(config-if)#no sh    // 启用该接口
Router(config-if)#end
Router#sh ip ro           // 查看路由表

```







# 7 三层交换机

### 7.1 三层交换机的作用

三层交换机结合了传统交换机和路由器的功能，主要用于在不同 VLAN 之间进行数据包转发和路由。它的主要作用包括：

1. **VLAN 间路由**：可以在不同 VLAN 之间快速转发数据包。
2. **提高网络性能**：通过硬件加速转发，提高了数据处理速度。
3. **减少延迟**：直接在交换机内部处理路由，减少数据在网络中的传输时间。
4. **灵活的网络设计**：支持动态和静态路由，适应复杂的网络架构。

### 7.2 解决的问题

- ==**跨 VLAN 通信**：允许不同 VLAN 的设备进行通信，解决了 VLAN 隔离的问题。==
- **网络管理**：简化了网络管理，通过集中管理提高了效率。
- **优化流量**：减少了对外部路由器的依赖，降低了网络延迟。

### ==7.3 配置过程总结==

1. **创建 VLAN**：
   - 在三层交换机上创建所需的 VLAN（如 VLAN 2、3、4）。

2. **配置接入端口**：
   - 将交换机的接口配置为接入模式，并将它们分配到相应的 VLAN。

3. ==**配置虚拟接口（SVI：set virtual inteface）**：==
   - ==为每个 VLAN 创建虚拟接口，并分配 IP 地址，以便为该 VLAN 的设备提供网关。==

4. ==**启用路由功能**：==
   - ==在三层交换机上启用 IP 路由功能，以支持 VLAN 之间的路由。==

5. **查看配置**：
   - 使用命令查看 VLAN 和路由表，确保配置正确。

通过以上步骤，三层交换机能够有效地管理不同 VLAN 之间的流量，实现快速、灵活的网络通信。

```c
三层交换机（O）
Switch>en                  // 进入特权模式
Switch#vl da               // 进入VLAN数据库模式
Switch(vlan)#vl 2          // 创建VLAN 2
Switch(vlan)#vl 3          // 创建VLAN 3
Switch(vlan)#vl 4          // 创建VLAN 4
Switch(vlan)#exit          // 退出VLAN数据库模式
Switch#conf t              // 进入全局配置模式

// 配置接口 f0/1 到 f0/2 为接入模式，并加入 VLAN 2
Switch(config)#in ra f0/1-2 // 进入接口范围 f0/1 到 f0/2
Switch(config-if-range)#sw mo ac  // 设置接口为接入模式
Switch(config-if-range)#sw ac vl 2  // 将接口加入VLAN 2
Switch(config-if-range)#exit // 退出接口范围配置

// 配置接口 f0/3 到 f0/4 为接入模式，并加入 VLAN 3
Switch(config)#in ra f0/3-4 // 进入接口范围 f0/3 到 f0/4
Switch(config-if-range)#sw mo ac  // 设置接口为接入模式
Switch(config-if-range)#sw ac vl 3  // 将接口加入VLAN 3
Switch(config-if-range)#exit // 退出接口范围配置

// 配置接口 f0/5 到 f0/6 为接入模式，并加入 VLAN 4
Switch(config)#in ra f0/5-6 // 进入接口范围 f0/5 到 f0/6
Switch(config-if-range)#sw mo ac  // 设置接口为接入模式
Switch(config-if-range)#sw ac vl 4  // 将接口加入VLAN 4
Switch(config-if-range)#end // 结束接口配置
Switch#sh vl               // 查看VLAN配置信息

Switch#conf t              // 进入全局配置模式
// 为每个VLAN配置虚拟接口（SVI）IP地址
Switch(config)#in vl 2     // 进入VLAN 2的虚拟接口
Switch(config-if)#ip ad 192.168.1.254 255.255.255.0 // 配置VLAN 2的IP地址
Switch(config-if)#exit      // 退出接口配置

Switch(config)#in vl 3     // 进入VLAN 3的虚拟接口
Switch(config-if)#ip ad 192.168.2.254 255.255.255.0 // 配置VLAN 3的IP地址
Switch(config-if)#exit      // 退出接口配置

Switch(config)#in vl 4     // 进入VLAN 4的虚拟接口
Switch(config-if)#ip ad 192.168.3.254 255.255.255.0 // 配置VLAN 4的IP地址
Switch(config-if)#exit      // 退出接口配置

Switch(config)#end          // 结束配置
Switch#sh ip ro            // 查看路由表

Switch#conf t              // 进入全局配置模式
Switch(config)#ip routing  // 启用路由功能
Switch(config)#end          // 结束配置
Switch#sh ip ro            // 再次查看路由表

```

![image-20241016090515292](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241016090515292.png)









# 8 标准ACL配置

## 8.1 ACL配置介绍

访问控制列表（ACL）是一种用于==控制网络流量的工具==，可以基于源IP地址、目标IP地址、协议类型和端口号等条件来允许或拒绝数据包。ACL主要用于提高网络安全性，限制访问特定资源。主要分为

1. **标准ACL**：仅基于源IP地址来过滤流量，通常用于允许或拒绝某个子网的访问。
2. **扩展ACL**：可以根据源和目标IP地址、协议类型和端口号进行更复杂的过滤。

## ==8.2 配置方法==

1. ==**创建ACL**：==

   - ==标准ACL：==
     
     ```C
     Router(config)# access-list <编号> permit|deny <源地址> <反掩码>
         
     Router(config)# access-list 1 permit 192.168.1.0 0.0.0.255
     ```
   - 扩展ACL：
     ```C
     Router(config)# access-list <编号> permit|deny <协议> <源地址> <反掩码> <目标地址> <目标反掩码> [eq <端口>]
         
     Router(config)# access-list 100 permit tcp 192.168.1.0 0.0.0.255 10.0.0.0 0.0.0.255 eq 80
     ```

2. ==**应用ACL到接口**：==

   ```plaintext
   Router(config)# interface <接口>
   Router(config-if)# ip access-group <编号> in|out
   
   Router(config)# interface f0/1
   Router(config-if)# ip access-group 1 in
   ```

3. **查看ACL配置**：
   ```plaintext
   Router# show access-list
   ```

### 示例

```C
三层交换机（O）
步骤一 创建Vlan划分端口，创建虚接口并为其配置为网关地址,并开启三层交换机的路由功能

步骤二 配置路由器的接口IP


步骤三 验证测试连通性


步骤四 配置路由
（1）配置交互机的路由
SW1#conf t  // 进入全局配置模式
SW1(config)#ip route 0.0.0.0 0.0.0.0 192.168.3.2  // 配置默认路由，指向 R1

(2)配置路由器的路由
R1#conf t  // 进入全局配置模式
R1(config)#ip route 192.168.1.0 255.255.255.0 192.168.3.1  // 配置到 VLAN 1 的静态路由
R1(config)#ip route 192.168.2.0 255.255.255.0 192.168.3.1  // 配置到 VLAN 2 的静态路由

（3）观察交互机和路由器的路由


（4）验证测试 PC 和 Server 的连通性


步骤五 在路由器上配置 ACL，只允许 IP 地址为 192.168.1.0/24 的所有计算机和 192.168.2.2 的计算机能够和访问服务器 Server0

R1#conf t  // 进入全局配置模式
R1(config)#access-list 2 permit 192.168.1.0 0.0.0.255 // 允许源网络为 192.168.1.0/24 的所有主机
R1(config)#access-list 2 permit host 192.168.2.2       // 允许主机 192.168.2.2
R1(config)#access-list 2 deny any  // 拒绝所有 IP，这也是 ACL 的默认隐含命令

R1(config)#in f0/1  // 进入接口 f0/1
Router(config-if)#ip access-group 2 out  // 在接口 f0/1 的出口方向应用 ACL
Router(config-if)#end  // 结束配置模式
Router#sh ru  // 显示当前运行配置

```

![image-20241020205121776](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020205121776.png)









# 9.静态NAT

## 9.1概述

NAT（Network Address Translation，网络地址转换）是一种用于修改网络数据包的源或目的 IP 地址的技术。静态 NAT 是其中一种模式，==用于将内部网络的私有 IP 地址静态映射为外部的公共 IP 地址，这样每个内部 IP 都有一个对应的外部 IP。==

- **内部地址**：私有网络的 IP 地址，需要被 NAT 进行转换。
- **外部地址**：公共网络的 IP 地址，是转换后的地址，通常可以在公共网络中路由。

==静态 NAT 的主要作用是解决私有 IP 地址和公共 IP 地址之间的直接通信问题，适用于数量有限且固定的 IP 地址转换。==



这段代码展示了如何在路由器上配置静态 NAT（网络地址转换），目的是将内部网络的私有 IP 地址映射为外部网络的公共 IP 地址，使内部网络的设备能够与外部网络设备通信。

### NAT 简介
NAT（Network Address Translation，网络地址转换）是一种用于修改网络数据包的源或目的 IP 地址的技术。静态 NAT 是其中一种模式，用于将内部网络的私有 IP 地址静态映射为外部的公共 IP 地址，这样每个内部 IP 都有一个对应的外部 IP。

- **内部地址**：私有网络的 IP 地址，需要被 NAT 进行转换。
- **外部地址**：公共网络的 IP 地址，是转换后的地址，通常可以在公共网络中路由。

静态 NAT 的主要作用是解决私有 IP 地址和公共 IP 地址之间的直接通信问题，适用于数量有限且固定的 IP 地址转换。

## 9.2配置过程及注释

---

**步骤一：配置路由器接口 IP 地址**

---

**步骤二：配置路由表**

1. **在 R1 上配置默认路由**
   
   - 设置默认路由指向 R2 的 `10.1.1.2`，让 R1 的数据包可以通过 R2 转发到外部网络：
     ```shell
     R1# configure terminal
     R1(config)# ip route 0.0.0.0 0.0.0.0 10.1.1.2
     R1(config)# end
     ```
---

**==步骤三：配置静态 NAT==**

1. **设置 NAT 内部和外部接口**
   
   - 在 R1 上，将 f0/0 接口设置为 NAT 内部接口，将 f0/1 接口设置为 NAT 外部接口：
     ```shell
     R1# configure terminal
     R1(config)# interface f0/0
     R1(config-if)# ip nat inside
     R1(config-if)# exit
     
     R1(config)# interface f0/1
     R1(config-if)# ip nat outside
     R1(config-if)# exit
     ```
   
2. **配置静态 NAT 映射**
   
   - 为 PC1 和 PC2 配置静态 NAT，将内部地址 `192.168.1.1` 和 `192.168.1.2` 分别映射为外部地址 `200.1.1.10` 和 `200.1.1.20`：
     ```shell
     R1(config)# ip nat inside source static 192.168.1.1 200.1.1.10
     R1(config)# ip nat inside source static 192.168.1.2 200.1.1.20
     ```
   - 这条命令创建了静态 NAT 映射，使得当内部网络的主机（如 PC1 和 PC2）与外部网络通信时，IP 地址被转换为对应的外部地址。
   
3. **验证 NAT**
   
   - 查看 NAT 转换表，确认 NAT 已成功应用：
     ```shell
     R1# show ip nat translations
     ```
     输出结果中显示了 Inside Global（转换后的外部 IP）和 Inside Local（原始内部 IP）的对应关系，确保 NAT 映射生效。
   
   ![image-20241030085330428](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241030085330428.png)

通过配置静态 NAT，使得内部 IP 地址（192.168.1.1 和 192.168.1.2）在与外部网络通信时分别被转换为 `10.1.1.10` 和 `10.1.1.20`。这样，内部网络的设备可以通过外部 IP 地址与服务器通信，而不需要服务器或外部设备知道内部网络的私有 IP 地址。

























# # 一些问题

## 1.前两个包一定会丢失，后面再ping时就不会丢包了

Q:为什么PC0第一次ping Server0时前两个包一定会丢失，后面再ping时就不会丢包了？

![image-20241020203850173](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020203850173.png)

A:

### 1. **ARP（地址解析协议）工作原理**
在一个网络中，设备间的通信不仅依赖于 IP 地址，还需要使用设备的 MAC 地址进行帧的传输。IP 地址用于逻辑层，而 MAC 地址用于数据链路层。

- 当 PC0 要 Ping Server0 时，它有 Server0 的 IP 地址（例如：10.1.1.2），但它不知道 Server0 的 MAC 地址。
- 为了找到这个 MAC 地址，PC0 会发起一个 **ARP 请求**。这个请求的作用是：“谁是 10.1.1.2？请告诉我你的 MAC 地址。”
- ARP 请求是一个广播包，发送到网络中的所有设备。所有设备都会接收到这个请求，但只有 Server0（拥有 IP 地址 10.1.1.2 的设备）会响应。

### 2. **首次 Ping 丢包的原因**
当 PC0 发起首次 Ping 时，前两个 ICMP 数据包（Ping 包）可能会丢失，这是因为：

- 在发送这两个包的过程中，PC0 还没有获取到 Server0 的 MAC 地址。

- PC0 首先必须完成 ARP 请求-应答的过程，才能将 Ping 数据包封装在以太网帧中发送出去。

  ==**ARP解析延迟**：当PC0第一次发送数据包给Server0时，它需要通过ARP（地址解析协议）来解析Server0的MAC地址。如果ARP缓存中没有Server0的MAC地址，PC0会发送ARP请求来获取。这个ARP请求和响应过程需要时间，**因此前几个数据包可能会在等待ARP解析完成时超时或丢失**。一旦ARP解析完成，后续的数据包就可以正常发送。==

### 3. **ARP 缓存的作用**
一旦 ARP 请求-应答过程完成，PC0 就会在本地缓存中存储 Server0 的 MAC 地址。这就是所谓的 **ARP 缓存**。

- 有了这个缓存，PC0 不需要再次发出 ARP 请求，它可以直接用 Server0 的 MAC 地址将后续的数据包发送出去。
- 因此，后续的 Ping 不再需要等待 ARP 的响应过程，Ping 包会立即发送并收到回应。

### 4. **总结过程**
- **第一次 Ping 丢包**：因为 PC0 需要通过 ARP 解析获取 Server0 的 MAC 地址。这个解析过程需要时间，所以 Ping 的前两个包在等待过程中可能会超时并丢失。
- **后续 Ping 不丢包**：ARP 缓存了 Server0 的 MAC 地址，PC0 可以直接发送数据包，因此不再有丢包现象。

### 5. **验证**
你可以通过在 PC0 上运行命令 `arp -a` 来查看缓存的 ARP 表，其中会列出已解析的 IP 地址和对应的 MAC 地址。你应该能够看到 Server0 的 MAC 地址已经被缓存。
