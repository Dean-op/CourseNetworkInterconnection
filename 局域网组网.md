# 1 Vlan Trunk

## 1.1 概念

### VLAN

VLAN（Virtual Local Area Network，虚拟局域网）==是一种将网络中的设备逻辑上分组的技术，尽管这些设备可能物理上位于不同的局域网中。==VLAN允许在同一物理网络基础设施上创建多个逻辑隔离的网络，使得不同的VLAN内的设备可以像在不同的局域网中一样通信，而无需物理分离。 

VLAN的主要特点：

1. ==**逻辑隔离**：每个VLAN是一个独立的广播域，不同VLAN之间的设备无法直接通信，除非通过三层设备（如路由器或三层交换机）。==
2. **灵活性和可扩展性**：VLAN可以跨越多台交换机，并且通过配置，网络管理员可以灵活地分配不同设备到不同的VLAN，而不受物理位置的限制。
3. **增强安全性**：通过将敏感设备分配到特定的VLAN，可以减少广播风暴的范围并隔离流量，提升网络安全性。

### TRUNK（中继）

==TRUNK是一种用于在交换机之间传输多个VLAN流量的链路。====它**允许不同的VLAN数据通过同一物理链路，保持每个VLAN的独立性**。==TRUNK链路上的流量使用**IEEE 802.1Q**封装协议，在每个以太帧中插入一个VLAN标记（Tag）以区分不同的VLAN。

TRUNK的主要特点：

1. ==**多VLAN数据传输**：TRUNK端口用于在多个交换机之间传输多个VLAN的流量，保持各VLAN的逻辑隔离。==
2. **802.1Q封装协议**：该协议在以太网帧中插入4字节的VLAN Tag字段，用于标识VLAN ID，这样交换机能够识别来自不同VLAN的帧。
3. **适用于跨交换机的VLAN扩展**：通过TRUNK连接不同交换机，可以实现VLAN在整个网络中的扩展。例如，VLAN 10在多个交换机上都可以存在，通过TRUNK端口在交换机之间转发VLAN 10的流量。

VLAN与TRUNK的关系：

- **VLAN**将网络中的设备分隔成不同的广播域，允许不同的部门或用户组逻辑隔离。
- **TRUNK**则用于在交换机之间传输这些VLAN的数据，确保每个VLAN的数据在多个交换机间传递时保持隔离。

## ==1.2 常用命令==

- 创建vlan

  ```c
  Switch#vlan database   //进入vlan数据库
  Switch(vlan)#vlan 2	//创建vlan2
  Switch(vlan)#vlan 3	//创建vlan3
  
  或进入全局配置模式直接创建vlan
  Switch(config)#vlan 4
  ```

  

- 将接口划分到指定vlan

  ```c
  Switch(config)#interface f0/2	//进入0模块2网口
  Switch(config-if)#switchport access vlan 2	//将0模块2网口加入vlan2
  
  将接口批量加入vlan
  Switch(config)#interface range f0/3-10	//进入3~10接口
  Switch(config-if)#switchport access vlan 2	//将3~10接口加入vlan2
  ```

  

- 切换接口模式

  ```c
  Switch(config)#interface f0/24  //进入接口
  Switch(config-if)#switchport  mode  trunk	//将0模块24网口模式切换为trunk
  ```

  







# 2 默认路由和静态路由

### 2.1 默认路由（Default Route）

==**默认路由**是一条特殊的路由，它用来处理发送到路由器但没有明确匹配路由表中任何目的地址的流量。==默认路由通常用于将未知目的地的流量发送到一个指定的网关。默认路由的网络地址是 `0.0.0.0/0`，也就是匹配所有地址。

**默认路由的用途**：

1. **出口路由**：默认路由经常用在小型或边缘网络，配置为通向ISP的出口路由，所有非本地网络的流量都会通过默认路由发送到ISP。
2. **节省路由表空间**：通过配置一条默认路由，网络管理员可以减少手动配置每个外部网络的具体路由，简化配置工作。


==**默认路由的配置方法：**==

假设我们有一个下一跳为 `192.168.1.1` 的路由器，默认路由的配置如下：

```c
Router(config)#ip route 0.0.0.0 0.0.0.0 192.168.1.1
```

- `0.0.0.0 0.0.0.0` 是默认路由的标志，匹配所有目标IP。
- `192.168.1.1` 是下一跳地址，所有未知目的地的流量都会发送到这个地址。

---

### 2.2 静态路由（Static Route）

==**静态路由**是网络管理员手动配置的特定路由，它将数据流量从一个网络转发到特定的目的地。==静态路由需要指定目标网络、子网掩码和下一跳地址或出接口。

**静态路由的特点**：

1. **手动配置**：与动态路由协议（如RIP、OSPF、BGP）不同，静态路由必须由管理员手动添加、修改和删除。
2. **无开销**：静态路由不会产生协议开销，因此在小型、固定拓扑的网络中非常高效。
3. **灵活控制**：网络管理员可以通过静态路由精确控制流量的路径，但在拓扑变化时需要手动调整。

==**静态路由的配置方法**：==

==假设有一条到 `192.168.2.0/24` 网络的静态路由，下一跳为 `192.168.1.2`，配置如下：==

```c
Router(config)#ip route 192.168.2.0 255.255.255.0 192.168.1.2
```

- `192.168.2.0` 是目标网络的地址。

- `255.255.255.0` 是子网掩码。

- `192.168.1.2` 是通向目标网络的下一跳地址。

  

**静态路由的另一种配置方式**（出接口方式）：

如果下一跳直接连接，可以指定出接口而不是下一跳IP地址。例如，配置到 `192.168.2.0` 的静态路由通过接口 `FastEthernet0/1`：

```c
Router(config)#ip route 192.168.2.0 255.255.255.0 FastEthernet0/1
```

---

### 2.3 默认路由与静态路由的区别：
1. **匹配方式**：静态路由是针对特定目标网络的，而默认路由适用于所有没有明确路由的流量。
2. **使用场景**：
   - 静态路由用于有明确网络拓扑和需要精确流量控制的情况。
   - 默认路由通常用于处理所有外部网络流量或小型网络的出口路由。
3. **管理负担**：静态路由需要人工维护，拓扑变化时要手动更新；默认路由较简单，通常配置一次即可应对大多数流量。

---

**==配置示例总结：==**

- 默认路由：`ip route 0.0.0.0 0.0.0.0 [next-hop]`
- 静态路由：`ip route [destination-network] [subnet-mask] [next-hop]`



# 3 RIP协议

### 3.1 RIP协议介绍

RIP（Routing Information Protocol）==是一个基于距离矢量的动态路由协议==，最早开发于20世纪80年代，用于小型网络。它通过周期性地与邻居路由器交换路由表来更新路由信息，进而实现动态路由的维护。==RIP的工作原理是通过**跳数**（Hop Count）来选择最佳路由路径，跳数即为数据包从源路由器到目标路由器之间经过的路由器数量。==

**RIP的主要特点：**

1. **距离矢量协议**：==RIP根据到达目标网络的跳数选择路径，跳数越少，路径越优。最大跳数为15，超过15跳的路由会被视为不可达。==
2. **定时更新**：==RIP默认每隔30秒向邻居路由器广播自己的路由表。==
3. **路由老化机制**：如果路由器在180秒内没有收到某条路由的更新，将认为该路由不可达并将其从路由表中删除。
4. **最大跳数限制**：RIP的最大跳数为15跳，超过此限制的网络将被视为不可达，这限制了RIP的适用范围，适合小型网络。

**RIP的版本：**

1. **RIPv1**：使用广播方式发送更新，不支持子网掩码，因此不支持VLSM（可变长子网掩码）和CIDR（无类别域间路由）。
2. **RIPv2**：通过多播地址 `224.0.0.9` 发送更新，支持VLSM和CIDR，能够更有效地处理现代网络。

---

### 3.2 RIP协议的配置方法

2. ==启用RIP协议==

```c
Router(config)#router rip
```

- **`router rip`**：进入RIP的配置模式，启用RIP协议。

3. ==指定RIP版本==

```c
Router(config-router)#version 2
```

- **`version 2`**：指定使用RIP版本2（RIPv2），它支持VLSM和CIDR。

4. ==配置网络==

```c
Router(config-router)#network 192.168.1.0
Router(config-router)#network 10.0.0.0
```

- ==**`network`**：该命令用于告诉RIP哪个网络要被通告，以及在哪些接口上发送RIP更新。==
- ==例如，**`network 192.168.1.0`** 表示路由器将通告192.168.1.0/24网络，并向连接这个网络的接口发送RIP更新。==

5. 配置RIP定时器（可选）

```c
Router(config-router)#timers basic 30 180 180 240
```

- **`timers basic`**：此命令配置RIP的更新间隔（30秒）、失效时间（180秒）、保持时间（180秒）和刷新时间（240秒）。可以根据网络需求进行优化配置。

7. 保存配置

```c
Router#write memory
```

- **`write memory`**：保存路由器配置，以确保路由器重启后配置仍然生效。

---

### 3.3 配置示例

假设我们有两个网络，`192.168.1.0/24` 和 `10.0.0.0/8`，我们在路由器上配置RIP并通告这两个网络。

```c
Router>enable
Router#configure terminal
Router(config)#router rip
Router(config-router)#version 2
Router(config-router)#network 192.168.1.0
Router(config-router)#network 10.0.0.0
Router(config-router)#end
Router#write memory
```

- **`router rip`**：启用RIP协议。
- **`version 2`**：指定使用RIPv2版本。
- **`network`**：将 `192.168.1.0/24` 和 `10.0.0.0/8` 网络加入到RIP的路由通告中。
- **`write memory`**：保存配置。

---

### 3.4 RIP协议的优缺点

优点：

- **简单易用**：配置简单，适合小型网络。
- **自动路由更新**：RIP可以动态学习和更新路由表，无需手动配置每条路由。

缺点：

- **跳数限制**：最大跳数为15，限制了RIP在大规模网络中的应用。
- **收敛速度慢**：RIP的更新间隔较长，收敛速度慢，可能会导致网络中断时延迟更新。
- **不适合复杂网络**：RIP不支持大规模和复杂网络，现代网络中大多使用更高级的路由协议如OSPF或EIGRP。

RIP协议通常在小型或简单网络中使用，大型网络则倾向于使用OSPF或BGP等更先进的动态路由协议。



# 4 OSPF协议

### 4.1 OSPF协议介绍

OSPF（Open Shortest Path First）==是一种基于链路状态的动态路由协议==，广泛应用于大型和复杂的IP网络中。它是由IETF（互联网工程任务组）开发并标准化的，属于内部网关协议（IGP）的一种。OSPF在许多企业和服务提供商网络中使用，因为它具备高效性和灵活性。

**OSPF的主要特点：**

1. ==**链路状态协议**：OSPF通过交换链路状态信息（LSA）来构建和维护路由表，每个路由器都可以独立计算到达每个网络的最佳路径。==
2. ==**区域划分**：OSPF可以将网络划分为多个区域，**区域0为骨干区域，其他区域通过骨干区域互联**。==这种设计可以提高路由的可扩展性和管理效率。
3. **快速收敛**：当网络拓扑发生变化时，OSPF能够快速收敛，更新路由信息，提高网络的稳定性。
4. **支持VLSM和CIDR**：OSPF支持可变长度子网掩码（VLSM）和无类别域间路由（CIDR），能够更有效地利用IP地址。
5. **多播更新**：OSPF使用多播地址（224.0.0.5和224.0.0.6）来发送更新信息，提高网络带宽的利用率。

==**OSPF的工作原理：**==

1. **邻居发现**：路由器通过发送Hello报文发现邻居路由器，建立邻接关系。
2. **LSA交换**：邻居路由器之间交换链路状态信息，路由器根据这些信息构建链路状态数据库（LSDB）。
3. **最短路径计算**：每个路由器使用Dijkstra算法计算到达每个目的地的最短路径，并更新路由表。
4. **周期性更新**：OSPF路由器定期发送LSA以维持网络状态的最新，确保路由信息的准确性。

---

### ==4.2 OSPF的配置方法==

在思科（Cisco）路由器上，配置OSPF的步骤如下：

**1. 启用OSPF协议**

```c
Router(config)#router ospf 1
```

- **`router ospf 1`**：启用OSPF协议，其中1是OSPF进程号。多个OSPF进程可以在同一路由器上运行，进程号是其唯一标识。

**2. 配置OSPF网络**

```c
Router(config-router)#network 192.168.1.0 0.0.0.255 area 0
Router(config-router)#network 192.168.2.0 0.0.0.255 area 1
```

- **`network`**：用于将指定的网络添加到OSPF进程中，并将其划分到特定区域。
  - `192.168.1.0 0.0.0.255 area 0`：将 `192.168.1.0/24` 网络添加到OSPF进程，并将其分配到区域0（骨干区域）。
  - `192.168.2.0 0.0.0.255 area 1`：将 `192.168.2.0/24` 网络添加到OSPF进程，并将其分配到区域1

---

### 4.3 配置示例

假设我们有两个网络，`192.168.1.0/24` 和 `192.168.2.0/24`，我们在路由器上配置OSPF并通告这两个网络。

```c
1. Router#ip routing
   // 启用路由功能，确保路由器可以进行IP路由。

2. Router(config)#router ospf 100
   // 启用OSPF协议，100是进程号，多个OSPF进程可以在同一路由器上运行。

3. Router(config-router)#network 192.168.1.0 0.0.0.255 area 1
   // 将192.168.1.0/24网络添加到OSPF进程中，并指定其属于区域1。反掩码（wildcard mask）0.0.0.255表示匹配192.168.1.0到192.168.1.255的所有地址。

4. Router(config-router)#network 192.168.2.0 0.0.0.255 area 0
   // 将192.168.2.0/24网络添加到OSPF进程中，并指定其属于区域0（骨干区域）。反掩码0.0.0.255同样表示匹配192.168.2.0到192.168.2.255的所有地址。

5. Router(config-router)#end
   // 退出OSPF配置模式，返回到特权模式。

6. Router#sh ip ro
   // 显示当前路由器的IP路由表，以检查OSPF学习到的路由。

7. Router#wr
   // 保存当前的配置，以确保在路由器重启后配置仍然生效。

```

### 4.4 OSPF协议的优缺点

优点：

- **快速收敛**：OSPF能快速响应网络拓扑的变化，适应性强。
- **支持大规模网络**：能够有效支持大型企业和服务提供商网络。
- **支持VLSM和CIDR**：更灵活的IP地址管理和分配。

缺点：

- **配置复杂性**：相较于RIP，OSPF的配置和管理更为复杂。
- **资源消耗**：OSPF在内存和CPU资源的消耗上相对较高，尤其是在大型网络中。

OSPF是现代网络设计中最常用的动态路由协议之一，适用于需要高效和灵活路由管理的环境。

![image-20241016082147790](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241016082147790.png)

# 5 单臂路由

### 5.1前缀概念

**默认网关**，就像是一个城市的大门，==是连接本地网络和外部网络的桥梁==。当你的电脑想要访问互联网上的其他设备（比如访问一个网站）时，如果目标设备不在你的本地网络中，你的电脑就会通过默认网关来转发这个请求。作用：

- **路由决策:** 当你的电脑需要向一个不在本地网络中的设备发送数据包时，它会查看自己的路由表。如果路由表中没有找到一条直接到达目标网络的路由，那么它就会将数据包发送给默认网关。

- **数据转发:** 默认网关（通常是一个路由器）会接收到这个数据包，然后根据它的路由表，决定将数据包转发到哪个网络。

- **连接不同网络:** 通过这种方式，默认网关连接了你的本地网络和外部网络，使得你的电脑可以访问互联网上的各种资源。

  

**单臂路由**，也称为“路由器上的棍子”，==是一种在路由器的一个物理接口上配置多个逻辑子接口，实现多个VLAN之间互联互通的技术。==简单来说，就是通过在路由器上创建一个虚拟的“手臂”，让多个VLAN“抓住”这个“手臂”，从而实现相互通信。

### 5.2 单臂路由的工作原理

1. ==**物理接口与逻辑子接口:**==

   - ==路由器上有一个物理接口连接到交换机。==
   - ==在这个物理接口上，配置多个逻辑子接口，每个逻辑子接口对应一个VLAN。==
   - ==路由器会对数据包进行封装和解封装，在不同的VLAN之间进行转发。==

2. ==**VLAN间的通信:**==

   - ==当一个VLAN中的主机需要向另一个VLAN中的主机发送数据时：==

     - ==数据包首先被封装上源VLAN的标签。==

     - ==路由器收到数据包后，根据VLAN标签，将数据包剥离原来的标签，并封装上目的VLAN的标签。==

     - ==然后，路由器将数据包转发到对应的逻辑子接口，最终到达目的主机。==

       

单臂路由的优点

- **节省接口资源:** 相比于为每个VLAN配置一个物理接口，单臂路由可以大大节省路由器的接口资源。
- **简化配置:** 配置相对简单，只需要在路由器上配置子接口和VLAN即可。
- **灵活扩展:** 可以根据需要增加或减少VLAN，方便网络的扩展。

### ==5.3单臂路由的配置方法==

单臂路由（One-Armed Routing）的配置方法允许通过单个物理接口处理多个 VLAN 的流量。下面是配置单臂路由的步骤和示例。

1. **创建 VLAN 分配接口至VLAN：**
  
   ```c
   Switch(config)# vlan 10
   Switch(config-vlan)# exit
   Switch(config)# vlan 20
   Switch(config-vlan)# exit
   Switch(config)# interface f0/1
   Switch(config-if)# switchport access vlan 10  // 将 f0/1 接口加入 VLAN 10
   Switch(config-if)# exit
   
   Switch(config)# interface f0/2
   Switch(config-if)# switchport access vlan 20  // 将 f0/2 接口加入 VLAN 20
   Switch(config-if)# exit
   ```
   
   
   
3. **配置 Trunk 接口**：
  
   - 配置一个 Trunk 接口，以便通过它传递多个 VLAN 的流量。
   
   ```c
   Switch(config)# interface f0/3
   Switch(config-if)# switchport mode trunk  // 将 f0/3 设置为 Trunk 模式
   Switch(config-if)# exit
   ```
   
6. ==**配置路由器的子接口**：==
  
   - 在路由器上创建子接口，使用 802.1Q 封装并为每个子接口配置 IP 地址。
   
   ```c
   Router(config)# interface f0/0
   Router(config-if)# no shutdown  // 启用接口
   
   Router(config)# interface f0/0.1
   Router(config-subif)# encapsulation dot1Q 10  // 封装 VLAN 10
   Router(config-subif)# ip address 192.168.1.254 255.255.255.0  // IP 地址
   Router(config-subif)# exit
   
   Router(config)# interface f0/0.2
   Router(config-subif)# encapsulation dot1Q 20  // 封装 VLAN 20
   Router(config-subif)# ip address 192.168.2.254 255.255.255.0  // IP 地址
   Router(config-subif)# exit
   ```
   
   `encapsulation dot1Q 10` 的意思是将该子接口（如 f0/0.1）配置为使用 802.1Q VLAN 封装协议，并指定该子接口将处理 VLAN 10 的流量。具体解释如下：
   
   1. **802.1Q 封装**：
      - ==802.1Q 是一种 VLAN 标记协议，用于在以太网帧中插入 VLAN 标签。这个标签包含了 VLAN 的信息，使得交换机和路由器能够识别数据包属于哪个 VLAN。==
   
   2. **VLAN 10**：
      - ==`10` 表示此子接口将处理属于 VLAN 10 的流量。==当 VLAN 10 中的设备发送数据包时，802.1Q 封装会在数据包中添加 VLAN 标签，以指示其 VLAN 所属。
   
   `encapsulation dot1Q 10` 配置使得路由器能够识别并处理 VLAN 10 的流量，同时支持通过该接口的多 VLAN 传输，实现 VLAN 间的路由功能。

![image-20241009171627342](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241009171627342.png)

















# 6 多端口路由器互联Vlan

### 6.1 解决的问题

- **VLAN 隔离**：
  - 各个 VLAN 内的设备能够互相通信，而 VLAN 之间的设备则需要通过路由器进行访问，保证了网络的隔离性。

- ==**跨 VLAN 路由**：==
  - ==配置的路由器能够提供不同 VLAN 之间的路由功能，使得不同 VLAN 内的设备能够进行数据交换。==

### ==6.2 路由器互联Vlan配置方法==

1. **交换机配置**：
   - **创建 VLAN**：
     - 在交换机上创建三个 VLAN（2、3、4），为不同的网络段做好划分。
   - **配置接入端口**：
     - 将接口 f0/1 到 f0/3 设置为接入模式，并加入 VLAN 2。
     - 将接口 f0/4 到 f0/6 设置为接入模式，并加入 VLAN 3。
     - 将接口 f0/7 到 f0/9 设置为接入模式，并加入 VLAN 4。
2. **路由器配置**：
   - **配置接口 IP 地址**：
     - 在路由器的 g0/0、g0/1 和 g0/2 接口上分别配置 IP 地址，作为 VLAN 2、3 和 4 的默认网关。
   - **启用接口**：
     - 确保所有配置的接口都处于启用状态。
   - **查看路由表**：
     - 使用 `show ip route` 命令确认路由表正确配置。

![image-20241016085902507](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241016085902507.png)

```c
Switch>en
Switch#vl da               // 进入VLAN数据库模式
Switch(vlan)#vl 2          // 创建VLAN 2
Switch(vlan)#vl 3          // 创建VLAN 3
Switch(vlan)#vl 4          // 创建VLAN 4
Switch(vlan)#exit
Switch#conf t              // 进入全局配置模式
Switch(config)#in ra f0/1-3 // 进入接口范围 f0/1 到 f0/3
Switch(config-if-range)#sw mo ac  // 将接口设置为接入模式
Switch(config-if-range)#sw ac vl 2  // 将接口加入VLAN 2
Switch(config-if-range)#exit
Switch(config)#in ra f0/4-6 // 进入接口范围 f0/4 到 f0/6
Switch(config-if-range)#sw mo ac  // 将接口设置为接入模式
Switch(config-if-range)#sw ac vl 3  // 将接口加入VLAN 3
Switch(config-if-range)#exit
Switch(config)#in ra f0/7-9 // 进入接口范围 f0/7 到 f0/9
Switch(config-if-range)#sw mo ac  // 将接口设置为接入模式
Switch(config-if-range)#sw ac vl 4  // 将接口加入VLAN 4
Switch(config-if-range)#end
Switch#sh vl               // 查看VLAN配置信息

Router>en
Router#conf t              // 进入全局配置模式
Router(config)#in g0/0     // 进入接口 g0/0
Router(config-if)#ip ad 192.168.1.254 255.255.255.0 // 配置IP地址
Router(config-if)#no sh    // 启用该接口
Router(config-if)#exit
Router(config)#in g0/1     // 进入接口 g0/1
Router(config-if)#ip ad 192.168.2.254 255.255.255.0 // 配置IP地址
Router(config-if)#no sh    // 启用该接口
Router(config-if)#exit
Router(config)#in g0/2     // 进入接口 g0/2
Router(config-if)#ip ad 192.168.3.254 255.255.255.0 // 配置IP地址
Router(config-if)#no sh    // 启用该接口
Router(config-if)#end
Router#sh ip ro           // 查看路由表

```







# 7 三层交换机

### 7.1 三层交换机的作用

三层交换机结合了传统交换机和路由器的功能，主要用于在不同 VLAN 之间进行数据包转发和路由。它的主要作用包括：

1. **VLAN 间路由**：可以在不同 VLAN 之间快速转发数据包。
2. **提高网络性能**：通过硬件加速转发，提高了数据处理速度。
3. **减少延迟**：直接在交换机内部处理路由，减少数据在网络中的传输时间。
4. **灵活的网络设计**：支持动态和静态路由，适应复杂的网络架构。

### 7.2 解决的问题

- ==**跨 VLAN 通信**：允许不同 VLAN 的设备进行通信，解决了 VLAN 隔离的问题。==
- **网络管理**：简化了网络管理，通过集中管理提高了效率。
- **优化流量**：减少了对外部路由器的依赖，降低了网络延迟。

### ==7.3 配置过程总结==

1. **创建 VLAN**：
   - 在三层交换机上创建所需的 VLAN（如 VLAN 2、3、4）。

2. **配置接入端口**：
   - 将交换机的接口配置为接入模式，并将它们分配到相应的 VLAN。

3. ==**配置虚拟接口（SVI：set virtual inteface）**：==
   - ==为每个 VLAN 创建虚拟接口，并分配 IP 地址，以便为该 VLAN 的设备提供网关。==

4. ==**启用路由功能**：==
   - ==在三层交换机上启用 IP 路由功能，以支持 VLAN 之间的路由。两台三层交换机互联需要配置路路由表==

5. **查看配置**：
   - 使用命令查看 VLAN 和路由表，确保配置正确。

通过以上步骤，三层交换机能够有效地管理不同 VLAN 之间的流量，实现快速、灵活的网络通信。

```c
三层交换机（O）
Switch>en                  // 进入特权模式
Switch#vl da               // 进入VLAN数据库模式
Switch(vlan)#vl 2          // 创建VLAN 2
Switch(vlan)#vl 3          // 创建VLAN 3
Switch(vlan)#vl 4          // 创建VLAN 4
Switch(vlan)#exit          // 退出VLAN数据库模式
Switch#conf t              // 进入全局配置模式

// 配置接口 f0/1 到 f0/2 为接入模式，并加入 VLAN 2
Switch(config)#in ra f0/1-2 // 进入接口范围 f0/1 到 f0/2
Switch(config-if-range)#sw mo ac  // 设置接口为接入模式
Switch(config-if-range)#sw ac vl 2  // 将接口加入VLAN 2
Switch(config-if-range)#exit // 退出接口范围配置

// 配置接口 f0/3 到 f0/4 为接入模式，并加入 VLAN 3
Switch(config)#in ra f0/3-4 // 进入接口范围 f0/3 到 f0/4
Switch(config-if-range)#sw mo ac  // 设置接口为接入模式
Switch(config-if-range)#sw ac vl 3  // 将接口加入VLAN 3
Switch(config-if-range)#exit // 退出接口范围配置

// 配置接口 f0/5 到 f0/6 为接入模式，并加入 VLAN 4
Switch(config)#in ra f0/5-6 // 进入接口范围 f0/5 到 f0/6
Switch(config-if-range)#sw mo ac  // 设置接口为接入模式
Switch(config-if-range)#sw ac vl 4  // 将接口加入VLAN 4
Switch(config-if-range)#end // 结束接口配置
Switch#sh vl               // 查看VLAN配置信息

Switch#conf t              // 进入全局配置模式
// 为每个VLAN配置虚拟接口（SVI）IP地址
Switch(config)#in vl 2     // 进入VLAN 2的虚拟接口
Switch(config-if)#ip ad 192.168.1.254 255.255.255.0 // 配置VLAN 2的IP地址
Switch(config-if)#exit      // 退出接口配置

Switch(config)#in vl 3     // 进入VLAN 3的虚拟接口
Switch(config-if)#ip ad 192.168.2.254 255.255.255.0 // 配置VLAN 3的IP地址
Switch(config-if)#exit      // 退出接口配置

Switch(config)#in vl 4     // 进入VLAN 4的虚拟接口
Switch(config-if)#ip ad 192.168.3.254 255.255.255.0 // 配置VLAN 4的IP地址
Switch(config-if)#exit      // 退出接口配置

Switch(config)#end          // 结束配置
Switch#sh ip ro            // 查看路由表

Switch#conf t              // 进入全局配置模式
Switch(config)#ip routing  // 启用路由功能
Switch(config)#end          // 结束配置
Switch#sh ip ro            // 再次查看路由表

```

![image-20241016090515292](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241016090515292.png)

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/imageimage-20241128092157141.png" alt="image-20241128092157141" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



### 7.4 虚拟局域网接口

虚拟局域网接口 (SVI, Switch Virtual Interface) ==是交换机的一种逻辑接口，用于为每个 VLAN 提供三层功能，==特别==是 **IP 路由** 和 **VLAN 内通信的网关功能**==。在网络中，SVI 是 VLAN 内设备与其他网络或 VLAN 通信的关键。

------

##### **什么是 SVI？**

- SVI 是一个与 VLAN 对应的逻辑接口。
- ==每个 VLAN 都可以有一个唯一的 SVI，充当该 VLAN 的网关。==
- ==配置了 SVI 后，交换机就能作为三层设备处理 VLAN 间的通信（需要三层交换支持）。==

------

##### **SVI 的作用**

1. **为 VLAN 分配网关 IP 地址**
   - 每个 VLAN 是一个独立的广播域，设备间通信需要一个网关。
   - SVI 的 IP 地址通常作为该 VLAN 内设备的默认网关。
2. **支持 VLAN 间路由**
   - 如果交换机支持三层功能，可以通过 SVI 实现不同 VLAN 之间的数据包路由。
   - 例如，VLAN 2 (192.168.1.0/24) 的设备需要与 VLAN 3 (192.168.2.0/24) 通信时，数据会通过 SVI 进行转发。
3. **管理交换机**
   - 如果分配 SVI 的 IP 地址给管理 VLAN（如 VLAN 1），可以通过该 IP 远程管理交换机（例如使用 SSH、Telnet）。



------

##### ==**如何配置 SVI？**==

以下是具体步骤：

**1. 进入全局配置模式**

```plaintext
Switch#configure terminal
```

**2. 为每个 VLAN 配置一个虚拟接口**

假设我们配置 VLAN 2 的 SVI：

```plaintext
Switch(config)#interface vlan 2
Switch(config-if)#ip address 192.168.1.254 255.255.255.0
Switch(config-if)#no shutdown
```

- `interface vlan 2`：创建或进入 VLAN 2 的 SVI。
- `ip address 192.168.1.254 255.255.255.0`：分配给 VLAN 2 的网关 IP 地址。
- `no shutdown`：确保接口是启用状态。

重复以上步骤为其他 VLAN 配置 SVI，例如：

```plaintext
Switch(config)#interface vlan 3
Switch(config-if)#ip address 192.168.2.254 255.255.255.0
Switch(config-if)#no shutdown

Switch(config)#interface vlan 4
Switch(config-if)#ip address 192.168.3.254 255.255.255.0
Switch(config-if)#no shutdown
```

**3. 验证 SVI 状态**

完成配置后，使用以下命令检查 SVI 是否正常工作：

```plaintext
Switch#show ip interface brief
```

------

**总结**

- SVI 的本质是为每个 VLAN 提供 IP 层接口。
- 它主要用于 VLAN 间通信和设备的网络管理。
- 配置 SVI 后，交换机不仅能处理二层数据包，还能通过三层路由实现跨 VLAN 通信。

如果你对某部分仍有疑问，可以举具体场景，我来进一步解释！











# 8 标准ACL配置

## 8.1 ACL配置介绍

访问控制列表（ACL）是一种用于==控制网络流量的工具==，可以基于源IP地址、目标IP地址、协议类型和端口号等条件来允许或拒绝数据包。ACL主要用于提高网络安全性，限制访问特定资源。主要分为

1. **标准ACL**：仅基于源IP地址来过滤流量，通常用于允许或拒绝某个子网的访问。
2. **扩展ACL**：可以根据源和目标IP地址、协议类型和端口号进行更复杂的过滤。

## ==8.2 配置方法==

1. ==**创建ACL**：==

   - ==标准ACL：==
     
     ```C
     Router(config)# access-list <编号（1-99）> permit|deny <源地址> <反掩码>
         
     Router(config)# access-list 1 permit 192.168.1.0 0.0.0.255
     ```
   
2. ==**应用ACL到接口**：==

   ```plaintext
   Router(config)# interface <接口>
   Router(config-if)# ip access-group <编号> in|out
   
   Router(config)# interface f0/1
   Router(config-if)# ip access-group 1 in
   ```

3. **查看ACL配置**：
   ```plaintext
   Router# show access-list
   ```

**示例**

```C
三层交换机（O）
步骤一 创建Vlan划分端口，创建虚接口并为其配置为网关地址,并开启三层交换机的路由功能

步骤二 配置路由器的接口IP


步骤三 验证测试连通性


步骤四 配置路由
（1）配置交互机的路由
SW1#conf t  // 进入全局配置模式
SW1(config)#ip route 0.0.0.0 0.0.0.0 192.168.3.2  // 配置默认路由，指向 R1

(2)配置路由器的路由
R1#conf t  // 进入全局配置模式
R1(config)#ip route 192.168.1.0 255.255.255.0 192.168.3.1  // 配置到 VLAN 1 的静态路由
R1(config)#ip route 192.168.2.0 255.255.255.0 192.168.3.1  // 配置到 VLAN 2 的静态路由

（3）观察交互机和路由器的路由


（4）验证测试 PC 和 Server 的连通性


步骤五 在路由器上配置 ACL，只允许 IP 地址为 192.168.1.0/24 的所有计算机和 192.168.2.2 的计算机能够和访问服务器 Server0

R1#conf t  // 进入全局配置模式
R1(config)#access-list 2 permit 192.168.1.0 0.0.0.255 // 允许源网络为 192.168.1.0/24 的所有主机
R1(config)#access-list 2 permit host 192.168.2.2       // 允许主机 192.168.2.2
R1(config)#access-list 2 deny any  // 拒绝所有 IP，这也是 ACL 的默认隐含命令

R1(config)#in f0/1  // 进入接口 f0/1
Router(config-if)#ip access-group 2 out  // 在接口 f0/1 的出口方向应用 ACL
Router(config-if)#end  // 结束配置模式
Router#sh ru  // 显示当前运行配置

```

![image-20241020205121776](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020205121776.png)





# 9 扩展ACL配置

```c
Router(config)# access-list <编号(100-199)> permit|deny <协议> <源地址> <反掩码> <目标地址> <目标反掩码> [eq <端口>]
    
Router(config)# access-list 100 permit tcp 192.168.1.0 0.0.0.255 10.0.0.0 0.0.0.255 eq 80
```

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/imageimage-20241128135236876.png" alt="image-20241128135236876" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



步骤一：配置各设备接口 IP 地址

```c
(1) 配置 SW1 的接口 IP

// 为 VLAN 10 配置虚拟接口并分配 IP 地址
SW1(config)#interface vlan 10  
SW1(config-if)#ip address 192.168.1.254 255.255.255.0
SW1(config-if)#no shutdown     // 启用接口
SW1(config-if)#exit

// 为 VLAN 20 配置虚拟接口并分配 IP 地址

// 配置 G0/1 端口为路由端口并分配 IP 地址
SW1(config)#interface g0/1     
SW1(config-if)#no switchport   // 设置为三层路由接口
SW1(config-if)#ip address 10.1.1.1 255.255.255.0
SW1(config-if)#no shutdown
SW1(config-if)#exit

// 将 F0/1-12 加入 VLAN 10
// 将 F0/13-24 加入 VLAN 20


(2) 配置 R1 的接口 IP
// 配置 G0/1 接口
// 配置 G0/0 接口


(3) 配置 R2 的接口 IP
// 配置 G0/0 接口
R2(config)#interface g0/0      
R2(config-if)#ip address 20.1.1.2 255.255.255.0
R2(config-if)#no shutdown
R2(config-if)#exit

// 配置 G0/1 接口


(4) 配置 SW2 的接口 IP
SW2(config)#vlan 30            // 创建 VLAN 30
SW2(config)#vlan 40            // 创建 VLAN 40

// 配置 VLAN 30 虚拟接口
SW2(config)#interface vlan 30  
SW2(config-if)#ip address 192.168.3.254 255.255.255.0
SW2(config-if)#no shutdown
SW2(config-if)#exit

// 配置 VLAN 40 虚拟接口


// 配置 G0/1 端口为路由接口
SW2(config)#interface g0/1     
SW2(config-if)#no switchport
SW2(config-if)#ip address 10.1.2.1 255.255.255.0
SW2(config-if)#no shutdown
SW2(config-if)#exit

// 将 F0/1-12 加入 VLAN 30
SW2(config)#interface range f0/1-12  
SW2(config-if-range)#switchport mode access
SW2(config-if-range)#switchport access vlan 30
SW2(config-if-range)#exit

// 将 F0/13-24 加入 VLAN 40

```

步骤二：配置路由协议 OSPF

```c
SW1>en
SW1#conf t
SW1(config)#ip routing                  // 启用路由功能
SW1(config)#router ospf 100             // 配置 OSPF 进程 100
SW1(config-router)#router-id 1.1.1.1    // 设置路由器 ID
SW1(config-router)#network 192.168.1.0 0.0.0.255 area 1
SW1(config-router)#network 192.168.2.0 0.0.0.255 area 1
SW1(config-router)#network 10.1.1.0 0.0.0.255 area 1
SW1(config-router)#end


R1>en
R1#conf t
R1(config)#router ospf 100
R1(config-router)#router-id 2.2.2.2
R1(config-router)#network 10.1.1.0 0.0.0.255 area 1
R1(config-router)#network 20.1.1.0 0.0.0.255 area 0
R1(config-router)#end


R2>en
R2#conf t
R2(config)#router ospf 100
R2(config-router)#router-id 3.3.3.3
R2(config-router)#network 20.1.1.0 0.0.0.255 area 0
R2(config-router)#network 10.1.2.0 0.0.0.255 area 2
R2(config-router)#end


SW2>en
SW2#conf t
SW2(config)#ip routing
SW2(config)#router ospf 100
SW2(config-router)#router-id 4.4.4.4
SW2(config-router)#network 192.168.3.0 0.0.0.255 area 2
SW2(config-router)#network 192.168.4.0 0.0.0.255 area 2
SW2(config-router)#network 10.1.2.0 0.0.0.255 area 2
SW2(config-router)#end

```

步骤三：配置扩展 ACL

利用扩展ACL禁止VL20和VL30互访，其他不受限制。

```c
(1) 在 SW1 配置扩展 ACL
SW1>en
SW1#conf t
SW1(config)#access-list 100 deny ip 192.168.2.0 0.0.0.255 192.168.3.0 0.0.0.255
SW1(config)#access-list 100 permit ip any any
SW1(config)#interface vlan 20
SW1(config-if)#ip access-group 100 in
SW1#end



(2) 在 SW2 配置扩展 ACL
SW2>en
SW2#conf t
SW2(config)#access-list 100 deny ip 192.168.3.0 0.0.0.255 192.168.2.0 0.0.0.255
SW2(config)#access-list 100 permit ip any any
SW2(config)#interface vlan 30
SW2(config-if)#ip access-group 100 in
SW2(config-if)#end

```



# 10.静态NAT

## 10.1概述

NAT（Network Address Translation，网络地址转换）是一种用于修改网络数据包的源或目的 IP 地址的技术。静态 NAT 是其中一种模式，==用于将内部网络的私有 IP 地址静态映射为外部的公共 IP 地址，这样每个内部 IP 都有一个对应的外部 IP。==

- **内部地址**：私有网络的 IP 地址，需要被 NAT 进行转换。
- **外部地址**：公共网络的 IP 地址，是转换后的地址，通常可以在公共网络中路由。

==静态 NAT 的主要作用是解决私有 IP 地址和公共 IP 地址之间的直接通信问题，适用于数量有限且固定的 IP 地址转换。==



这段代码展示了如何在路由器上配置静态 NAT（网络地址转换），目的是将内部网络的私有 IP 地址映射为外部网络的公共 IP 地址，使内部网络的设备能够与外部网络设备通信。

### NAT 简介
NAT（Network Address Translation，网络地址转换）是一种用于修改网络数据包的源或目的 IP 地址的技术。静态 NAT 是其中一种模式，用于将内部网络的私有 IP 地址静态映射为外部的公共 IP 地址，这样每个内部 IP 都有一个对应的外部 IP。

- **内部地址**：私有网络的 IP 地址，需要被 NAT 进行转换。
- **外部地址**：公共网络的 IP 地址，是转换后的地址，通常可以在公共网络中路由。

静态 NAT 的主要作用是解决私有 IP 地址和公共 IP 地址之间的直接通信问题，适用于数量有限且固定的 IP 地址转换。

## 10.2配置过程及注释

---

**步骤一：配置路由器接口 和主机IP 地址**

---

**步骤二：配置路由表**

1. **在 R1 上配置默认路由**
   
   - 设置默认路由指向 R2 的 `10.1.1.2`，让 R1 的数据包可以通过 R2 转发到外部网络：
     ```shell
     R1# configure terminal
     R1(config)# ip route 0.0.0.0 0.0.0.0 10.1.1.2
     R1(config)# end
     ```
---

**==步骤三：配置静态 NAT==**

1. **设置 NAT 内部和外部接口**

   - 在 R1 上，将 f0/0 接口设置为 NAT 内部接口，将 f0/1 接口设置为 NAT 外部接口：
     ```shell
     R1# configure terminal
     R1(config)# interface f0/0
     R1(config-if)# ip nat inside
     R1(config-if)# exit
     
     R1(config)# interface f0/1
     R1(config-if)# ip nat outside
     R1(config-if)# exit
     ```

2. **配置静态 NAT 映射**

   ```c
   ip nat inside source static <内部IP> <外部IP>
   ```

   - 为 PC1 和 PC2 配置静态 NAT，将内部地址 `192.168.1.1` 和 `192.168.1.2` 分别映射为外部地址 `200.1.1.10` 和 `200.1.1.20`：
     ```shell
     R1(config)# ip nat inside source static 192.168.1.1 200.1.1.10
     R1(config)# ip nat inside source static 192.168.1.2 200.1.1.20
     ```
   - 这条命令创建了静态 NAT 映射，使得当内部网络的主机（如 PC1 和 PC2）与外部网络通信时，IP 地址被转换为对应的外部地址。
   
3. **验证 NAT**

   - 查看 NAT 转换表，确认 NAT 已成功应用：
     ```shell
     R1# show ip nat translations
     ```
     输出结果中显示了 Inside Global（转换后的外部 IP）和 Inside Local（原始内部 IP）的对应关系，确保 NAT 映射生效。

   ![image-20241030085330428](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241030085330428.png)

通过配置静态 NAT，使得内部 IP 地址（192.168.1.1 和 192.168.1.2）在与外部网络通信时分别被转换为 `10.1.1.10` 和 `10.1.1.20`。这样，内部网络的设备可以通过外部 IP 地址与服务器通信，而不需要服务器或外部设备知道内部网络的私有 IP 地址。







# 11.动态NAT与NAPT

```bash
# 步骤一：配置设备的接口IP地址
# R1接口IP地址：略
# R2接口IP地址：略

# 步骤二：配置设备的路由
# 配置R1的默认路由
R1>en
R1#conf t
R1(config)#ip route 0.0.0.0 0.0.0.0 10.1.1.2   # 在R1上配置默认路由，指向R2（下一跳地址是10.1.1.2）
R1(config)#end
R1#sh ip ro   # 查看R1的路由表信息，确认默认路由已成功配置

# 查看R2的路由信息
R2#sh ip ro  # 查看R2的路由表，确认是否有适当的路由

# 验证PC1和Server0的连通性
# 验证PC2和Server0的连通性

# 说明：
# 计算机PC1和PC2无法与Server0通信的原因是：数据包从PC1经过R1路由器转发到R2，然后R2将数据包转发到Server0。但是，Server0返回的数据包从R2到达R1时，没有匹配到正确的路由表项（因为R2没有通向192.168.1.0网络的路由），导致数据包丢失。

# 步骤三：在R1上配置动态NAT
# 设置R1的内部转换接口
R1(config)#in f0/0
R1(config-if)#ip nat inside   # 在R1的f0/0接口上设置为“内部NAT”接口，表示此接口的IP地址属于私有网络
R1(config-if)#exit

# 设置R1的外部转换接口
R1(config)#in f0/1
R1(config-if)#ip nat outside  # 在R1的f0/1接口上设置为“外部NAT”接口，表示此接口的IP地址属于公网
R1(config-if)#exit

# 定义访问控制列表（ACL）
R1(config)#access-list 1 permit 192.168.1.0 0.0.0.255  # 定义ACL 1，允许192.168.1.0/24网络的IP地址进行NAT转换

# 定义内部全局地址池
R1(config)#ip nat pool jx 10.1.1.100 10.1.1.101 netmask 255.255.255.0   # 创建一个NAT地址池，池内地址为10.1.1.100至10.1.1.101（公网地址池）

# 应用动态NAT
R1(config)#ip nat inside source list 1 pool jx   # 将ACL 1（允许的内部地址）与地址池jx（公网地址池）关联，用于动态NAT转换

# 步骤四：验证PC和Server0的连通性
# PC1尝试ping 100.1.1.2
PC>ping 100.1.1.2    # 通，表示PC1已能够通过NAT访问Server0

# PC2尝试ping 100.1.1.2
PC>ping 100.1.1.2    # 通，表示PC2也能够通过NAT访问Server0

# R1查看NAT转换表
R1#sh ip nat tr   # 显示当前NAT转换表，列出所有内外部IP和端口转换的映射
# 转换表中会列出一些如下内容：
# Pro  Inside global     Inside local       Outside local      Outside global
# icmp 10.1.1.100:115    192.168.1.1:115    100.1.1.2:115      100.1.1.2:115
# icmp 10.1.1.100:116    192.168.1.1:116    100.1.1.2:116      100.1.1.2:116
# icmp 10.1.1.100:117    192.168.1.1:117    100.1.1.2:117      100.1.1.2:117
# icmp 10.1.1.100:118    192.168.1.1:118    100.1.1.2:118      100.1.1.2:118
# 这些是NAT表项，显示了源地址和目的地址的转换情况。

# 分析：在这种情况下，由于三台主机尝试使用相同的两个公有IP地址（10.1.1.100和10.1.1.101），如果更多主机同时发起连接，会发生冲突。为了解决这个问题，可以使用NAPT技术来区分不同的主机。

# 步骤五：应用NAPT（网络地址端口转换）
# 撤销当前的NAT配置
R1(config)#no ip nat inside source list 1   # 撤销原先配置的动态NAT

# 配置NAPT
Router(config)#ip nat inside source list 1 pool jx overload  # 使用“overload”选项将多个内部主机的请求映射到同一个公网IP地址，但是会使用不同的端口号来区分每个主机的连接

# 验证PC和Server0的连通性
# PC1尝试ping 100.1.1.2
PC>ping 100.1.1.2    # 通，表示PC1仍然可以通过NAPT访问Server0

# PC2尝试ping 100.1.1.2
PC>ping 100.1.1.2    # 通，表示PC2也可以继续通过NAPT访问Server0

# 再次查看NAT转换表
R1#sh ip nat tr   # 此时转换表显示NAT映射依然存在，但是多个主机共享相同的公网IP地址，通过端口号区分
# NAPT转换表可能如下所示：
# Pro  Inside global     Inside local       Outside local      Outside global
# icmp 10.1.1.100:115    192.168.1.1:115    100.1.1.2:115      100.1.1.2:115
# icmp 10.1.1.100:116    192.168.1.1:116    100.1.1.2:116      100.1.1.2:116
# icmp 10.1.1.101:117    192.168.1.2:117    100.1.1.2:117      100.1.1.2:117
# icmp 10.1.1.101:118    192.168.1.2:118    100.1.1.2:118      100.1.1.2:118

# 结论：NAPT技术允许多台计算机共享少量的公网IP地址，并通过端口号来区分不同的连接。这种方式可以解决地址资源紧张的问题。
```

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/imageimage-20241129091752470.png" alt="image-20241129091752470" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

### 动态NAT和NAPT的配置步骤总结

==**动态NAT配置步骤：**==

1. 配置动态NAT：

   - 配置接口的NAT角色（内部和外部接口）。

   - 定义一个ACL，指定哪些内部地址需要进行NAT转换。

     ```c
     R1(config)#access-list 1 permit 192.168.1.0 0.0.0.255  
         # 定义ACL 1，允许192.168.1.0/24网络的IP地址进行NAT转换
     ```

     

   - 创建并配置一个NAT地址池，定义公网地址池的范围。

     ```c
     ip nat pool <pool_name> <address_lower> <address_upper> netmask <netmask_code>   
          # 创建一个NAT地址池，池内地址为address_lower至address_upper（公网地址池）
          # 地址范围是闭区间
     ```

   - 应用动态NAT，将内部网络的地址通过NAT池映射到公网地址。

     ```c
     R1(config)#ip nat inside source list 1 pool pool_name   
         # 将ACL 1（允许的内部地址）与地址池pool_name（公网地址池）关联，用于动态NAT转换.
     ```

     

2. **验证NAT配置**：通过ping测试，确保内网设备能够通过公网地址访问外网，并查看NAT转换表确认转换是否生效。

==**NAPT配置步骤：**==

1. **撤销现有NAT配置**：通过`no ip nat inside source list 1`撤销之前的动态NAT配置。

2. 应用NAPT：

   - 使用`overload`选项，将多个内部设备的连接通过端口号映射到少量公网IP地址上。

     ```c
     Router(config)#ip nat inside source list 1 pool jx overload  
         # 使用“overload”选项将多个内部主机的请求映射到同一个公网IP地址，但是会使用不同的端口号来区分每个主机的连接
     ```

     













# 12.三层交换机上配置DHCP

## 12.1DHCP介绍

参考**4.2.6 动态主机配置协议(DHCP)**

## ==12.2 DHCP配置步骤==

1. **排除关键IP地址**：
    使用 `ip dhcp excluded-address` 将关键的静态地址（如网关、服务器地址）从DHCP分配池中排除。
2. **创建DHCP地址池**：
   - 使用 `ip dhcp pool [名称]` 创建地址池。
   - 设置地址池的网络范围，命令：`network [网段] [子网掩码]`。
   - 指定默认网关地址，命令：`default-router [网关地址]`。
   - 设置DNS服务器地址，命令：`dns-server [DNS地址]`。
3. **验证配置**：
   - 使用 `show running-config` 检查配置是否正确。
   - 配置完成后，可以在客户端测试是否能正确获取到IP地址、网关和DNS。
4. **客户端测试连接**：
   - 确保客户端的网络接口设置为自动获取IP地址。
   - 使用 `ipconfig /release` 和 `ipconfig /renew` 重新获取IP地址。
   - 验证连通性：用 `ping` 命令测试客户端与外网的通信。
5. **排查问题**：
    如果DHCP未正常工作，检查以下内容：
   - DHCP服务器的配置是否正确。
   - VLAN的路由是否启用。
   - 各接口是否已启用`ip routing`功能。

```c
SW0配置DHCP

SW0(config)#ip dhcp excluded-address 192.168.10.1    //排除VLAN 10的网关地址，避免被分配
SW0(config)#ip dhcp excluded-address 192.168.20.1    //排除VLAN 20的网关地址
SW0(config)#ip dhcp excluded-address 192.168.30.1    //排除VLAN 30的网关地址
SW0(config)#ip dhcp excluded-address 192.168.40.1    //额外排除非使用中的地址

SW0(config)#ip dhcp pool 10                          //创建VLAN 10的DHCP地址池
SW0(dhcp-config)#network 192.168.10.0 255.255.255.0  //指定地址池的网络范围
SW0(dhcp-config)#default-router 192.168.10.1         //设置默认网关（VLAN 10的网关地址）
SW0(dhcp-config)#dns-server 202.100.192.68           //设置DNS服务器地址
SW0(dhcp-config)#exit                                //退出地址池配置

SW0(config)#ip dhcp pool 20                          //创建VLAN 20的DHCP地址池
SW0(dhcp-config)#network 192.168.20.0 255.255.255.0  //指定地址池的网络范围
SW0(dhcp-config)#default-router 192.168.20.1         //设置默认网关（VLAN 20的网关地址）
SW0(dhcp-config)#dns-server 202.100.192.68           //设置DNS服务器地址
SW0(dhcp-config)#exit                                //退出地址池配置

SW0(config)#ip dhcp pool 30                          //创建VLAN 30的DHCP地址池
SW0(dhcp-config)#network 192.168.30.0 255.255.255.0  //指定地址池的网络范围
SW0(dhcp-config)#default-router 192.168.30.1         //设置默认网关（VLAN 30的网关地址）
SW0(dhcp-config)#dns-server 202.100.192.68           //设置DNS服务器地址
SW0(dhcp-config)#exit                                //退出地址池配置
    
验证DHCP可以分配IP地址、网关和DNS
将PC1，PC2，PC3的IP Configuration 设置成DHCP自动获取

PC>ipconfig /release    //释放IP地址
   IP Address......................: 0.0.0.0
   Subnet Mask.....................: 0.0.0.0
   Default Gateway.................: 0.0.0.0
   DNS Server......................: 0.0.0.0

PC1>ipconfig /renew   //获取IP地址
   IP Address......................: 192.168.10.2
   Subnet Mask.....................: 255.255.255.0
   Default Gateway.................: 192.168.10.1
   DNS Server......................: 202.100.192.68

PC1>ping 100.1.1.2     //测试连通性
Pinging 100.1.1.2 with 32 bytes of data:

Reply from 100.1.1.2: bytes=32 time=1ms TTL=126
Reply from 100.1.1.2: bytes=32 time=0ms TTL=126
Reply from 100.1.1.2: bytes=32 time=0ms TTL=126
Reply from 100.1.1.2: bytes=32 time=0ms TTL=126

PC2和PC3同上

```

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/imageimage-20241201143218488.png" alt="image-20241201143218488" width="70%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>





# 13.交换机端口聚合

## 13.1 端口聚合介绍

端口聚合（EtherChannel）

端口聚合是一种网络技术==，通过将多个物理接口捆绑在一起形成一个逻辑链路（==称为端口通道，Port-Channel），实现以下目的：

1. **增加带宽**：将多个物理链路的带宽合并为一个逻辑带宽。例如，捆绑4个1Gbps的接口可以形成一个4Gbps的逻辑链路。
2. **提高冗余性**：如果某个成员接口发生故障，其他接口仍然可以继续工作，不会影响逻辑链路的运行。
3. **简化管理**：捆绑后，所有成员接口作为一个逻辑接口管理，大大简化了配置。

------

**工作特点**

1. **负载均衡**：
    流量分布在成员接口之间，具体方式根据交换机的负载均衡算法（如基于源/目的IP、MAC、端口等）来决定。
2. **冗余性**：
    如果一个物理接口发生故障，其流量会自动转移到其他正常工作的成员接口，避免中断通信。
3. **逻辑链路管理**：
    捆绑后的端口通道被视为一个逻辑接口，所有网络协议（如VLAN、Trunk、STP等）都基于逻辑接口工作，而不直接操作成员接口。

------

**配置模式**

端口聚合可以通过两种方式配置：

1. **静态模式**：
   - 手动启用聚合，不使用任何动态协商协议。
   - 配置命令：`channel-group [编号] mode on`。
2. **动态协商模式**：
   - 使用链路聚合控制协议（LACP，IEEE 802.3ad）或PAgP（Cisco专有协议）来动态协商接口的捆绑。
   - 配置命令：
     - LACP：`channel-group [编号] mode active/passive`。
     - PAgP：`channel-group [编号] mode desirable/auto`。



## 13.2 配置步骤

1. ==**配置通道组**：==

   - ==选择用于聚合的物理接口范围，使用 `interface range` 命令进入接口范围。==
   - ==启用端口聚合并加入一个通道组，命令：`channel-group [编号] mode on`。==

2. ==**配置聚合接口模式**：==

   - ==进入生成的逻辑接口 `interface port-channel [编号]`。==
   - ==将接口设置为Trunk模式，命令：`switchport mode trunk`。==
   - ==配置允许通过的VLAN，命令：`switchport trunk allowed vlan [编号,编号...]`。==
   - ==启用接口，命令：`no shutdown`。==

3. **验证配置**：

   - 查看当前配置，命令：`show running-config`。
   - 显示聚合状态，命令：`show etherchannel summary`。

   <div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/imageimage-20241201151718051.png" alt="image-20241201151718051" width="50%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

```c
SW1配置

1. 创建vlan 划分vlan

2. 配置通道组
S1#conf t                             //进入全局配置模式
S1(config)#in ra g0/1-2               //进入接口范围g0/1和g0/2
S1(config-if-range)#channel-group 3 mode on  //将接口加入通道组3，手动模式启用聚合
S1(config-if-range)#exit              //退出接口范围配置模式
S1config)#in port-channel 3           //进入逻辑接口port-channel 3
S1(config-if)#sw mo tr                //将聚合接口设置为Trunk模式
S1(config-if)#sw tr al vl 10,20       //允许VLAN 10和VLAN 20通过Trunk接口
S1(config-if)#no sh                   //启用接口
S1(config-if)#end                     //退出全局配置模式
S1#sh ru                              //显示当前配置
S1#sh etherchannel summary            //显示EtherChannel摘要信息

SW2配置
Switch>en                             //进入特权模式
Switch#vl da                          //进入VLAN数据库模式
Switch(vlan)#vl 10                    //创建VLAN 10
Switch(vlan)#vl 20                    //创建VLAN 20
Switch(vlan)#exit                     //退出VLAN数据库模式
Switch#conf t                         //进入全局配置模式
Switch(config)#ho S2                  //设置主机名为S2
S2(config)#in f0/1                    //进入接口f0/1
S2(config-if)#sw mo ac                //将接口模式设置为Access模式
S2(config-if)#sw ac vl 10             //将接口分配到VLAN 10
S2(config-if)#exit                    //退出接口配置模式
S2(config)#in f0/2                    //进入接口f0/2
S2(config-if)#sw mo ac                //将接口模式设置为Access模式
S2(config-if)#sw ac vl 20             //将接口分配到VLAN 20
S2(config-if)#exit                    //退出接口配置模式
S2(config)#end                        //退出全局配置模式
S2#sh vl                              //显示VLAN配置信息

S2#conf t                             //进入全局配置模式
S2(config)#in ra g0/1-2               //进入接口范围g0/1和g0/2
S2(config-if-range)#channel-group 3 mode on  //将接口加入通道组3，手动模式启用聚合
S2(config-if-range)#exit              //退出接口范围配置模式
S2(config)#in port-channel 3          //进入逻辑接口port-channel 3
S2(config-if)#sw mo tr                //将聚合接口设置为Trunk模式
S2(config-if)#sw tr al vl 10,20       //允许VLAN 10和VLAN 20通过Trunk接口
S2(config-if)#no sh                   //启用接口
S2(config-if)#end                     //退出全局配置模式
S2#sh ru                              //显示当前配置
S2#sh etherchannel summary            //显示EtherChannel摘要信息
```

















# 14.VTP配置

## 14.1 VTP介绍

**VTP（VLAN Trunking Protocol）简介**

==**VTP**（VLAN Trunking Protocol）是思科交换机中用于在同一网络中的多台交换机之间管理和同步 VLAN 配置的协议。==通过使用 VTP，网络管理员可以集中创建、修改、删除 VLAN 配置，这些更改会自动传播到 VTP 域内的所有交换机，减少了人工逐台配置的工作量，同时降低了配置错误的风险。

------

### **VTP 的主要功能**

1. **简化 VLAN 管理：**
    ==在 VTP 服务器上创建或修改 VLAN 后，这些配置会自动同步到域内的所有交换机。==
2. **同步 VLAN 信息：**
    确保所有交换机具有相同的 VLAN 信息，避免因配置不一致导致通信问题。
3. **减少配置工作量：**
    对于大型网络，VTP 可以减少逐台交换机手动配置的复杂性。
4. **动态更新：**
    VLAN 的创建、删除、命名等更新会自动传播，无需手动同步。

------

### **VTP 的工作模式**

1. **Server 模式：**
   - 默认模式，允许创建、删除、修改 VLAN。
   - ==分发 VLAN 配置到所有客户端和透明模式交换机。==
   - 每个 VTP 域中至少需要一个服务器。
2. **Client 模式：**
   - 不允许本地创建、删除、修改 VLAN。
   - ==从服务器学习 VLAN 配置，并应用这些配置。==
3. **Transparent 模式：**
   - 本地管理 VLAN，但不参与 VTP 同步。
   - ==转发 VTP 信息到相邻设备，但不学习或应用这些信息。==

------

### **VTP 的组成部分**

1. **VTP 域名（Domain Name）：**
    ==交换机必须在相同的域名下才能共享 VLAN 信息。==
2. **配置修订号（Configuration Revision Number）：**
    标识 VLAN 配置的版本号，用于确保客户端接收最新的 VLAN 配置。
3. **VTP 密码（可选）：**
    增加安全性，只有配置相同密码的交换机才能交换 VTP 信息。
4. **Pruning 功能：**
    减少不必要的 VLAN 流量转发，仅允许 VLAN 流量到达实际需要的交换机。

### **VTP 的重要命令**

1. **查看 VTP 状态：**

   ```plaintext
   show vtp status
   ```

   - 检查 VTP 域名、模式、修订号、VTP 密码等信息。

2. **配置 VTP 域名：**

   ```plaintext
   vtp domain <domain_name>
   ```

3. **配置 VTP 模式：**

   ```plaintext
   vtp mode {server | client | transparent}
   ```

4. **配置 VTP 密码：**

   ```plaintext
   vtp password <password>
   ```

5. **启用修剪功能：**

   ```plaintext
   vtp pruning
   ```

------

通过合理配置和使用 VTP，可以大大提升 VLAN 配置管理的效率，同时减少网络配置的复杂性。



## ==14.2 VTP配置过程==

**==1. 设置基本信息**==

- ==为每台交换机配置主机名以便于区分。==

- ==**确保所有交换机的 VTP 域名一致。**==

  ```c
  SW1(config)#vtp domain NAME
  ```

==**2. 配置 VTP 模式**==

- ==VTP 服务器（Server）：创建、修改 VLAN 并将其分发至整个域（核心设备配置）。==

- ==VTP 客户端（Client）：学习服务器发送的 VLAN 信息并应用（边缘设备配置）。==

- ==VTP 透明（Transparent）：不参与 VTP VLAN 同步，仅转发 VTP 信息（特殊场景使用）。==

  ```c
  vtp mode {server | client | transparent}
  ```

==**3. 配置 Trunk 接口**==

- ==确保连接交换机的接口为 Trunk 模式，以便于 VLAN 信息在交换机之间传输。==

**4. 创建和管理 VLAN**

- 在 VTP 服务器上创建 VLAN，并为各端口分配 VLAN。

**5. 配置 VTP 密码**

- 如果启用了 VTP 密码保护，确保所有交换机配置相同的密码。

**6. 验证配置**

- 使用命令检查 VLAN 和 VTP 状态是否正确：
  - `show vlan brief`：查看 VLAN 信息。
  - `show vtp status`：查看 VTP 状态，检查配置版本号是否同步。

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/imageimage-20241201155109734.png" alt="image-20241201155109734" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

```c
VTP 配置流程

一、在 SW1 配置 VTP
1. Switch>en                  // 进入特权模式
2. Switch#conf t              // 进入全局配置模式
3. Switch(config)#ho sw1      // 设置交换机的主机名为 SW1
4. SW1(config)#vtp domain hd  // 设置 VTP 域名为 "hd"，所有设备需匹配
5. SW1(config)#vtp mode server // 配置为 VTP 服务器模式，能创建、修改和分发 VLAN 配置
6. SW1(config)#in f0/23       // 进入接口 f0/23
7. SW1(config-if)#sw mo tr    // 配置接口为 Trunk 模式，允许 VLAN 通信
8. SW1(config-if)#end         // 退出配置模式

二、在 SW2 配置 VTP
1. Switch>en                  // 进入特权模式
2. Switch#conf t              // 进入全局配置模式
3. Switch(config)#ho sw2      // 设置交换机的主机名为 SW2
4. SW2(config)#vtp domain hd  // 设置 VTP 域名为 "hd"，需与 SW1 匹配
5. SW2(config)#vtp mode transparent // 配置为 VTP 透明模式，仅转发 VTP 信息但不学习
6. SW2(config)#in f0/23       // 进入接口 f0/23
7. SW2(config-if)#sw mo tr    // 配置接口为 Trunk 模式
8. SW2(config-if)#exit        // 退出接口配置模式
9. SW2(config)#in f0/24       // 进入接口 f0/24
10. SW2(config-if)#sw mo tr   // 配置接口为 Trunk 模式
11. SW2(config-if)#end        // 退出配置模式

三、在 SW3 配置 VTP
1. Switch>en                  // 进入特权模式
2. Switch#conf t              // 进入全局配置模式
3. Switch(config)#ho sw3      // 设置交换机的主机名为 SW3
4. SW3(config)#vtp domain hd  // 设置 VTP 域名为 "hd"
5. SW3(config)#vtp mode client // 配置为 VTP 客户端模式，学习并应用服务器发送的 VLAN 信息
6. SW3(config)#in f0/24       // 进入接口 f0/24
7. SW3(config-if)#sw mo tr    // 配置接口为 Trunk 模式
8. SW3(config-if)#exit        // 退出接口配置模式
9. SW3(config-if)#end         // 退出配置模式

四、在 SW1 上配置 VLAN
9. SW1#vl da                  // 进入 VLAN 数据库模式
10. SW1(vlan)#vl 2 na 17dz    // 创建 VLAN 2，名称为 "17dz"
11. SW1(vlan)#vl 3 na 18dz    // 创建 VLAN 3，名称为 "18dz"
12. SW1(vlan)#exit            // 退出 VLAN 数据库模式
13. SW1#conf t                // 进入全局配置模式
14. SW1(config)#in ra f0/1-2  // 进入接口范围 f0/1 到 f0/2
15. SW1(config-if-range)#sw mo ac // 配置接口为 Access 模式
16. SW1(config-if-range)#sw ac vl 2 // 将接口分配到 VLAN 2
17. SW1(config-if-range)#exit // 退出接口范围模式
18. SW1(config)#in ra f0/3-4  // 进入接口范围 f0/3 到 f0/4
19. SW1(config-if-range)#sw mo ac // 配置接口为 Access 模式
20. SW1(config-if-range)#sw ac vl 3 // 将接口分配到 VLAN 3
21. SW1(config-if-range)#exit // 退出接口范围模式
22. SW1(config)#in vl 1       // 进入 VLAN 1 接口
23. SW1(config-if)#ip ad 192.168.1.1 255.255.255.0 // 配置管理 IP 地址
24. SW1(config-if)#no sh      // 启用接口
25. SW1(config-if)#end        // 退出配置模式
26. SW1#sh vl br              // 查看 VLAN 配置信息
27. SW1#sh vtp status         // 查看 VTP 状态信息
```









# 15.路由重分布

## 15.1 路由重分布介绍

**路由重分布（Route Redistribution）** ==是网络中一种将一个路由协议学习到的路由信息转发到另一个路由协议的过程。==它主要用于以下场景：

- **多协议网络**：一个网络中运行多种路由协议（如 OSPF 和 RIP），需要实现互通。
- **网络迁移**：将旧的路由协议逐步替换为新的路由协议时需要确保不同协议的互通性。
- **特殊需求**：某些特定区域的网络需要以不同的方式运行，导致使用不同的路由协议。

通过路由重分布，可以实现网络之间的互联和信息的无缝传播。

------

**路由重分布的特点**

1. **单向重分布**：只将一种协议的路由信息引入另一种协议。
2. **双向重分布**：两种协议间互相引入对方的路由信息。
3. **度量值（Metric）**：不同协议的度量值算法不同（如 RIP 使用跳数，OSPF 使用链路成本），需要在重分布时显式设置。
4. **复杂性**：重分布可能导致环路、次优路由等问题，因此需要精心规划。
5. **过滤控制**：通过访问控制列表（ACL）或路由策略过滤器，可以限制特定路由的重分布。



------

**示例**

**场景：**
 网络中包含运行 OSPF 的区域 A 和运行 RIP 的区域 B，需要实现互通。使用 R2 路由器作为重分布节点。

**配置示例：**

```c
# 在 R2 上将 OSPF 路由重分布到 RIP
R2(config)#router rip
R2(config-router)#redistribute ospf 100 metric 2  // 指定度量值为 2
R2(config-router)#version 2
R2(config-router)#no auto-summary

# 在 R2 上将 RIP 路由重分布到 OSPF
R2(config)#router ospf 100
R2(config-router)#redistribute rip subnets       // 使用 subnets 引入精确路由
```



## 15.2 路由重分布配置过程

**路由重分布的配置步骤**

1. ==**启用路由协议**：确保网络中的路由协议运行正常，学习到各自的本地路由。==
2. ==**进入路由配置模式**：使用命令 `router <protocol>`，进入需要配置重分布的路由协议模式。==
3. ==执行重分布命令：==
   - ==在目标协议中使用 `redistribute <source_protocol>` 命令，将源协议的路由信息引入目标协议。==
   - ==如果目标协议需要指定度量值（如 RIP），需要使用 `metric` 参数设置初始度量值。==
4. **优化路由**：通过访问控制列表（ACL）、前缀列表（Prefix List）等过滤机制，限制不需要的路由传播。
5. **验证路由表**：使用 `show ip route` 确认路由是否正确分布。
6. **测试连通性**：使用 `ping` 或 `traceroute` 测试全网连通性。
7. **保存配置**：确保配置在设备重启后不会丢失。

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/imageimage-20241203151942186.png" alt="image-20241203151942186" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

```c
# 步骤一：IP地址配置
R1 IP配置
略

R2 IP配置
1. Router>en                                    // 进入特权模式
2. Router#conf t                               // 进入全局配置模式
3. Router(config)ho  R2                        // 修改路由器名字为 R2
4. R2(config)#in f0/0                          // 进入接口 f0/0
5. R2(config-if)#ip ad 2.1.1.2 255.255.255.0   // 配置接口 IP 地址和子网掩码
6. R2(config-if)#no sh                         // 启用接口
7. R2(config-if)#exit                          // 退出接口配置模式
8. R2(config)#in f0/1                          // 进入接口 f0/1
9. R2(config-if)#ip address 3.1.1.1 255.255.255.0 // 配置接口 IP 地址和子网掩码
10. R2(config-if)#no sh                        // 启用接口
11. R2(config-if)#end                          // 退出配置模式
12. R2#sh ru                                   // 查看路由器配置，确认 IP 配置正确

R3 IP配置
略

# 步骤二：路由配置
R1 路由配置
1. R1#conf t                                   // 进入全局配置模式
2. R1(config)#router ospf 100                  // 启用 OSPF 协议，进程号为 100
3. R1(config-router)#network 1.1.1.0 0.0.0.255 area 0 // 宣告 1.1.1.0 网络到 OSPF
4. R1(config-router)#network 2.1.1.0 0.0.0.255 area 0 // 宣告 2.1.1.0 网络到 OSPF
5. R1(config-router)#end                       // 退出路由配置模式
6. R1#sh ip ro                                 // 查看路由表，确认未学习到其他网络
7. R1#wr                                       // 保存配置

R2 路由配置
1. R2#conf t                                   // 进入全局配置模式
2. R2(config)#router ospf 100                  // 启用 OSPF 协议，进程号为 100
3. R2(config-router)#network 2.1.1.0 0.0.0.255 area 0 // 宣告 OSPF 网络
4. R2(config-router)#exit                      // 退出路由器配置模式
5. R2(config)#router rip                       // 启用 RIP 协议
6. R2(config-router)#network 3.1.1.0           // 宣告 RIP 网络
7. R2(config-router)#version 2                 // 使用 RIPv2
8. R2(config-router)#no auto-summary           // 禁用自动汇总
9. R2(config-router)#end                       // 退出路由器配置模式
10. R2#sh ip ro                                // 查看路由表
11. R2#wr                                      // 保存配置

R3 路由配置
1. R3#conf t                                   // 进入全局配置模式
2. R3(config)#router rip                       // 启用 RIP 协议
3. R3(config-router)#network 3.1.1.0           // 宣告 3.1.1.0 网络到 RIP
4. R3(config-router)#network 4.1.1.0           // 宣告 4.1.1.0 网络到 RIP
5. R3(config-router)#version 2                 // 使用 RIPv2
6. R3(config-router)#no auto-summary           // 禁用自动汇总
7. R3#sh ip ro                                 // 查看路由表，确认未学习到其他网络
8. R3#wr                                      // 保存配置

# 步骤三：路由重分发
R2 配置路由重分发
1. R2#conf t                                   // 进入全局配置模式
2. R2(config)#router ospf 100                  // 进入 OSPF 配置
3. R2(config-router)#redistribute rip subnets  // 将 RIP 路由重分发到 OSPF
4. R2(config-router)#exit                      // 退出路由器配置模式
5. R2(config)#router rip                       // 进入 RIP 配置
6. R2(config-router)#redistribute ospf 100 metric 2 // 将 OSPF 路由重分发到 RIP，指定度量值为 2
7. R2(config-router)#end                       // 退出路由器配置模式
8. R2#wr                                       // 保存配置

# 步骤四：查看路由表
1. R1#sh ip ro                                 // 查看路由表，确认学习到 3.1.1.0 和 4.1.1.0
2. R3#sh ip ro                                 // 查看路由表，确认学习到 1.1.1.0 和 2.1.1.0

# 步骤五：实验验证
PC1 Ping PC2                                    // 测试连通性，Ping 4.1.1.1 成功回复
```



# 16.三层交换机配置STP





















# # 一些问题

## 1.前两个包一定会丢失，后面再ping时就不会丢包了

Q:为什么PC0第一次ping Server0时前两个包一定会丢失，后面再ping时就不会丢包了？

![image-20241020203850173](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020203850173.png)

A:

### 1. **ARP（地址解析协议）工作原理**
在一个网络中，设备间的通信不仅依赖于 IP 地址，还需要使用设备的 MAC 地址进行帧的传输。IP 地址用于逻辑层，而 MAC 地址用于数据链路层。

- 当 PC0 要 Ping Server0 时，它有 Server0 的 IP 地址（例如：10.1.1.2），但它不知道 Server0 的 MAC 地址。
- 为了找到这个 MAC 地址，PC0 会发起一个 **ARP 请求**。这个请求的作用是：“谁是 10.1.1.2？请告诉我你的 MAC 地址。”
- ARP 请求是一个广播包，发送到网络中的所有设备。所有设备都会接收到这个请求，但只有 Server0（拥有 IP 地址 10.1.1.2 的设备）会响应。

### 2. **首次 Ping 丢包的原因**
当 PC0 发起首次 Ping 时，前两个 ICMP 数据包（Ping 包）可能会丢失，这是因为：

- 在发送这两个包的过程中，PC0 还没有获取到 Server0 的 MAC 地址。

- PC0 首先必须完成 ARP 请求-应答的过程，才能将 Ping 数据包封装在以太网帧中发送出去。

  ==**ARP解析延迟**：当PC0第一次发送数据包给Server0时，它需要通过ARP（地址解析协议）来解析Server0的MAC地址。如果ARP缓存中没有Server0的MAC地址，PC0会发送ARP请求来获取。这个ARP请求和响应过程需要时间，**因此前几个数据包可能会在等待ARP解析完成时超时或丢失**。一旦ARP解析完成，后续的数据包就可以正常发送。==

### 3. **ARP 缓存的作用**
一旦 ARP 请求-应答过程完成，PC0 就会在本地缓存中存储 Server0 的 MAC 地址。这就是所谓的 **ARP 缓存**。

- 有了这个缓存，PC0 不需要再次发出 ARP 请求，它可以直接用 Server0 的 MAC 地址将后续的数据包发送出去。
- 因此，后续的 Ping 不再需要等待 ARP 的响应过程，Ping 包会立即发送并收到回应。

### 4. **总结过程**
- **第一次 Ping 丢包**：因为 PC0 需要通过 ARP 解析获取 Server0 的 MAC 地址。这个解析过程需要时间，所以 Ping 的前两个包在等待过程中可能会超时并丢失。
- **后续 Ping 不丢包**：ARP 缓存了 Server0 的 MAC 地址，PC0 可以直接发送数据包，因此不再有丢包现象。

### 5. **验证**
你可以通过在 PC0 上运行命令 `arp -a` 来查看缓存的 ARP 表，其中会列出已解析的 IP 地址和对应的 MAC 地址。你应该能够看到 Server0 的 MAC 地址已经被缓存。





## 2.单臂路由和SVI区别

**单臂路由 (Router-on-a-Stick)** 和 **SVI (Switch Virtual Interface)** 是实现 VLAN 间通信的两种不同技术。它们的主要区别在于实现方式、适用场景和硬件的角色分工。下面详细介绍它们的原理、特点和区别。

---

### **1. 单臂路由 (Router-on-a-Stick)**

**原理**

- ==使用路由器的一个物理接口（通常是 **GigabitEthernet** 或 **FastEthernet**）。==
- ==在这个物理接口上配置多个 **逻辑子接口**，每个子接口关联一个 VLAN。==
- ==通过 **802.1Q** 或 **ISL（已废弃）** 协议在子接口上实现 VLAN 的封装和解封装。==
- 路由器根据逻辑子接口的配置进行 VLAN 间的路由。

**配置**

以下是单臂路由的典型配置示例：

```plaintext
Router(config)#interface GigabitEthernet0/0
Router(config-if)#no shutdown

Router(config)#interface GigabitEthernet0/0.10
Router(config-subif)#encapsulation dot1Q 10
Router(config-subif)#ip address 192.168.1.1 255.255.255.0

Router(config)#interface GigabitEthernet0/0.20
Router(config-subif)#encapsulation dot1Q 20
Router(config-subif)#ip address 192.168.2.1 255.255.255.0
```

**特点**

1. **基于路由器**
   - 路由器负责所有 VLAN 间的通信。
   - 路由器的逻辑子接口充当 VLAN 的网关。

2. **数据处理效率较低**
   - 数据需要从交换机发到路由器，再返回交换机，这种**“双向流量”**可能成为瓶颈。

3. **适用小型网络**
   - 适用于 VLAN 较少的场景，通常 2-5 个 VLAN。

---

### **2. SVI (Switch Virtual Interface)**

**原理**

- ==在支持三层功能的交换机上，为每个 VLAN 配置一个逻辑接口 (SVI)。==
- ==SVI 直接在交换机内部完成 VLAN 间的路由，无需依赖外部设备。==
- 数据包不会离开交换机，因此处理效率较高。

**配置**

以下是 SVI 的典型配置示例：

```plaintext
Switch(config)#interface vlan 10
Switch(config-if)#ip address 192.168.1.1 255.255.255.0
Switch(config-if)#no shutdown

Switch(config)#interface vlan 20
Switch(config-if)#ip address 192.168.2.1 255.255.255.0
Switch(config-if)#no shutdown
```

**特点**

1. **基于三层交换机**
   - 交换机既充当二层设备（VLAN 划分），又充当三层设备（路由）。
   - SVI 是 VLAN 的网关。

2. **数据处理效率高**
   - 数据包在交换机内部完成转发，不需要外部路由器。
   - 适合大规模网络。

3. **适用大型网络**
   - 支持更多 VLAN，且扩展性强。

---

### **3. 单臂路由 vs. SVI 的主要区别**

| **比较维度**        | **单臂路由 (Router-on-a-Stick)**             | **SVI (Switch Virtual Interface)**                 |
| ------------------- | -------------------------------------------- | -------------------------------------------------- |
| **实现设备**        | 路由器                                       | 三层交换机                                         |
| **网关角色**        | 路由器逻辑子接口                             | 交换机的 SVI                                       |
| **数据转发路径**    | VLAN 数据从交换机发往路由器，再返回交换机    | 数据包在交换机内部直接完成路由                     |
| **性能**            | 性能较低，流量瓶颈容易出现在路由器的单接口   | 性能高，适合处理大流量和高并发                     |
| **适用场景**        | 小型网络，VLAN 数量少，路由器是现有设备      | 中大型网络，三层交换机可满足大规模 VLAN 间通信需求 |
| **VLAN 间通信速度** | 较慢，需经过外部路由器的转发                 | 快速，交换机内部完成路由                           |
| **扩展性**          | 扩展能力有限，逻辑子接口数量受路由器接口限制 | 扩展能力强，支持更多 VLAN                          |
| **802.1Q 协议支持** | 必须在子接口上启用 802.1Q 封装               | SVI 使用 VLAN ID 隐式绑定，无需手动封装            |









## 3.路由重分布中禁用自动汇总作用

**`no auto-summary` 就是关闭路由聚合**，特别是在 RIP 协议中默认的**主类边界汇总**。简单来说：

- **开启路由聚合（默认行为）**：路由器会自动将子网的路由汇总成主类网络地址进行广播。
  - 例如：`192.168.1.0/24` 和 `192.168.2.0/24` 会被汇总为 `192.168.0.0/16`。
  - 优点：节省路由表条目，适合简单的网络。
  - 缺点：在复杂网络中，可能会导致路由不准确甚至冲突。

- **关闭路由聚合（`no auto-summary`）**：路由器会保留子网掩码信息，并广播精确的子网路由。
  - 例如：直接发送 `192.168.1.0/24` 和 `192.168.2.0/24`。
  - 优点：适用于复杂的网络环境（如使用不连续子网或 VLSM），确保路由精确性。
  - 缺点：路由表可能会增加更多条目，占用更多资源。

==`no auto-summary` 就是**关闭自动的路由聚合行为**，让路由器能够在路由更新中发送具体的子网路由信息，而不是汇总后的主类网络地址。==在现代复杂网络中，这种精确性非常重要。

`R2(config-router)#no auto-summary` 是在使用 RIP 协议时，禁用 **自动汇总（Auto-Summary）** 功能的命令。这一命令的作用主要体现在路由更新中。

---

**作用**

1. **默认行为（开启自动汇总）**：
   - RIP 的默认行为是将子网掩码路由汇总为其所属主类网络地址发送。例如：
     - 如果在网络中宣告 `192.168.1.0/24` 和 `192.168.2.0/24`，默认情况下，RIP 会将这些子网汇总为 `192.168.0.0/16` 发送给其他路由器。
   - 这种行为可能导致：
     - 路由不准确，甚至路由环路问题。
     - 在使用不连续子网（Discontiguous Subnets）时，可能导致路由器无法到达特定子网。

2. **禁用自动汇总（no auto-summary）**：
   - ==禁用后，RIP 会在路由更新中发送 **精确子网信息**（包括子网掩码）。例如：==
     - 如果宣告 `192.168.1.0/24` 和 `192.168.2.0/24`，禁用自动汇总后，RIP 会分别发送这两个子网而不是汇总为 `192.168.0.0/16`。
   - 适合：
     - 使用 VLSM（可变长子网掩码）时。
     - 不连续子网配置时。

---









